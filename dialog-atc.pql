PROCEDURE      DIALOG.ATC:T  (157511,51982)  |Last amended Jan 13, 2014,14:26:22
|| Generated by DP - don't edit anything outside |{...|}

|{ Header
| Creator:   Greg Neils
| Created:   1/01/2007
| Updated:   about every 3 months
| Called by: When a SIR session starts without a DB
| Reason:    Display a list of DBs to connect to.
print back noremarks nocommands user
GCOMPUTE COMMENT = '| '
attribute POISON    filename = '<GDATA4>DCC\ATC\POISON.log'
attribute MST_BAD   filename = '<GDATA4>DCC\ATC\MST_BAD.txt'
attribute MST_FIXED filename = '<GDATA4>DCC\ATC\MST_FIXED.txt'
attribute LOCK_DBS  filename = '<GDATA4>DCC\ATC\LOCKED_DBS.log'
|
| SIGN ON AS A DIFFERENT USER.  UN-CIF THIS CODE.
CIF EQ '<USERA>', 'GNEILS'
program
string  *   32    WHO_ARE_YOU  | ALLOWS US TO CHANGE GLOBAL USERA VALUE
integer *    2    DUMB_NUM#  | Use whenever you want to.
exit program
ifthen ('<USERA>' eq 'GNEILS')| or 'HANDREWS' OR 'DMERLE')
. WHO_ARE_YOU = 'AFRIEND'
. display textbox "Who are you?" response resvar, WHO_ARE_YOU
. if (len(TRIMLR(WHO_ARE_YOU)) > 0) DUMB_NUM# = globals('USERA', upper(WHO_ARE_YOU))
. WHO_ARE_YOU = '2'
. display textbox "Security Level: Pick a number between 300 and 400." response resvar, WHO_ARE_YOU
. if (len(TRIMLR(WHO_ARE_YOU  )) > 0) DUMB_NUM# = globals('GSECLEV', WHO_ARE_YOU  )
endif
end program
CIF END
|
|
program crwarn
|}

integer*2 m_id, m_arg1, m_arg2

integer*1 IDSTATIC; preset IDSTATIC (-1)
integer*1 IDCLOSE ; preset IDCLOSE  ( 0)
integer*1 ID_00002                        ; preset ID_00002                         (1 )
integer*1 CUR_DBS$                        ; preset CUR_DBS$                         (2 )
integer*1 DB_IS                           ; preset DB_IS                            (3 )
integer*1 DB_PATH                         ; preset DB_PATH                          (4 )
integer*1 MST_NUM#                        ; preset MST_NUM#                         (5 )
integer*1 UNKUSER                         ; preset UNKUSER                          (6 )
integer*1 CUR_DBS                         ; preset CUR_DBS                          (7 )
integer*1 DB_NAME                         ; preset DB_NAME                          (8 )
integer*1 DB_CON                          ; preset DB_CON                           (9 )
integer*1 DB_CLONE                        ; preset DB_CLONE                         (10 )
integer*1 SIN_CON                         ; preset SIN_CON                          (11 )
integer*1 DB_BCKUP                        ; preset DB_BCKUP                         (12 )
integer*1 EXITALL                         ; preset EXITALL                          (13 )
integer*1 SETDPROC                        ; preset SETDPROC                         (14 )
integer*1 DB_NONE                         ; preset DB_NONE                          (15 )
integer*1 P_HEAD                          ; preset P_HEAD                           (16 )
integer*1 READ_WARN                       ; preset READ_WARN                        (17 )
integer*1 CLEAR_WARN                      ; preset CLEAR_WARN                       (18 )
integer*1 LOCK_DB                         ; preset LOCK_DB                          (19 )
integer*1 LOCK_READ                       ; preset LOCK_READ                        (20 )
integer*1 LOCK_ALL                        ; preset LOCK_ALL                         (21 )
integer*1 LOCK_LIST                       ; preset LOCK_LIST                        (22 )
integer*1 LOCK_LAB                        ; preset LOCK_LAB                         (23 )
integer*1 DBA_NOTE                        ; preset DBA_NOTE                         (24 )
integer*1 LINE2AA                         ; preset LINE2AA                          (25 )
integer*1 LINE6AA                         ; preset LINE6AA                          (26 )
integer*1 LINE3AA                         ; preset LINE3AA                          (27 )
integer*1 LINE5AA                         ; preset LINE5AA                          (28 )
integer*1 LINE1AA                         ; preset LINE1AA                          (29 )
integer*1 LINE4AA                         ; preset LINE4AA                          (30 )
integer*1 B_DEV_DB                        ; preset B_DEV_DB                         (31 )
integer*1 USERSTATS                       ; preset USERSTATS                        (32 )
integer*1 ATC_FEEDBACK                    ; preset ATC_FEEDBACK                     (33 )

|{ Prologue
|}

dialog "Connect to your database"

|{ Controls
postype 1
line     ID_00002                        ,   0, 268,   0, 509
label    CUR_DBS$                        ,  76,       18,  80, "Already connected to..."
label    DB_IS                           ,  74,      180, 128, "Double Click the Database Name"
label    DB_PATH                         , 242,      156, 148, "Changes...............sadfasfaffadsf"
label    MST_NUM#                        , 252,      156, 148, "Master#"
label    UNKUSER                         ,  63,      180, 121, "Changes by log in"
list     CUR_DBS                         ,  86,  57,  18,  99, 0
list     DB_NAME                         ,  84, 154, 180, 116, 0
button   DB_CON                          ,  92,      323,  72, 1, "Connect"
button   DB_CLONE                        , 175,      324,  72, 0, "Cloned DB"
button   SIN_CON                         , 110,      323,  72, 0, "&Single User"
button   DB_BCKUP                        , 211,      323,  72, 0, "From Backup"
button   EXITALL                         ,  70,      412,  72, 0, "Exit"
button   SETDPROC                        ,  92,      412,  72, 0, "&DCCPROCF"
button   DB_NONE                         , 110,      412,  72, 0, "SIR"
image    P_HEAD                          ,   1,  58,   2, 506, 0
button   READ_WARN                       , 142,      412,  72, 0, "Read Warnings"
button   CLEAR_WARN                      , 160,      412,  72, 0, "Clear Warnings"
button   LOCK_DB                         , 197,      412,  72, 0, "Lock DBNAME"
button   LOCK_READ                       , 211,      412,  72, 0, "Read Locks"
button   LOCK_ALL                        , 238,      412,  72, 0, "Lock Everything"
list     LOCK_LIST                       , 170,  57,  18,  99, 0
label    LOCK_LAB                        , 159,       18, 100, "Double click to unlock."
label    DBA_NOTE                        ,  62,       18, 146, "Poison Pill Active"
line     LINE2AA                         , 128,   1, 436,  24
line     LINE6AA                         , 201,   1, 347,  24
line     LINE3AA                         , 178,   1, 436,  24
line     LINE5AA                         , 128,   1, 347,  24
line     LINE1AA                         ,  86,   1, 436,  24
line     LINE4AA                         , 228,   1, 436,  24
button   B_DEV_DB                        , 143,      324,  72, 0, "Develop DB"
button   USERSTATS                       , 182,      412,  72, 0, "View Usage"
label    ATC_FEEDBACK                    , 258,      326, 172, "Good Day!"
|}

initial
|{ Attribs
|< DB_IS
. SET ITEM FONT DB_IS,1,0,0, 0,"#0000C0"
|>
|< DBA_NOTE
. SET ITEM FONT DBA_NOTE,1,0,0, 1,"#C0C0FF/#000000"
. SET ITEM FONT DBA_NOTE,1,0,0, 1,"#C0C0FF/#000000"
|>

|}
|{ Init
string  *  256    STR$1  STR$2                       | helpful to construct strings for execution and messages
integer *    1    DB#                                | ARRAY # corresponding to the DB
string  *   32    MST_IP                             | Master IP address.  Databases can get a specific master IP.
integer *    4    MST_NUM                            | MST_NUM if from the file
integer *    4    CONNSTAT                           | Did the database connect
integer *    1    REGISTER_USER                      | Check to see if user has any access
integer *    1    YESNOVAR                           | Run Sign in first yes no answer
string  *  200    FILELINE$                          | lines in the
string  *  256    OTH_NAME                           | Open other DB.  Commented out on 11/2008
string  *  256    OTH_PATH                           | Open other DB path.  Commented out on 11/2008
string  *   10    EXT                                | file extension for a sysproc subroutine
string  *  256    OTH_ARGS                           | Open other DB Args.  Passing arguements to SIR members
integer *    1    OTH_NUM                            | Opth other DB. list of last DB used.
integer *    2    OTH_DBCOUNT                        | How many previous DBs are listed in the SIR.INI file
string  *   32    THIS_USER                          | Username
string  *   50    DB_NAME$                           | Name of database
string  *  300    DB_DSN SIR_PATH CHK_PATH           | To find out if it is a DB in the Counting DB.
string  *   32    HTML_COLOR                         | What color should the SIR background window be?
integer *    2    DUMB_NUM#                          | Use whenever you want to.
integer *    1    ADD_MST                            | Do they need to connect to master
string  *   32    array LOCKED_DB_ARRAY (32)         | Which DBs are locked.
string  *   32    CHECK_DBNAME_LOCK                  | Name in the text file of the locked or unlocked DB
string  *    8    CHECK_DBSTAT_LOCK                  | Status: LOCKED   or   UNLOCKED
integer *    1    DB_IS_LOCKED                       | 1 = LOCKED... ONLY ADMINS.    0= NOT LOCKED, EVERYONE.
string  *  100    LAST_DB_NAME                         | Last database accessed
string  *  100    USER_LOG                            | Location of user log information
integer *    1    SHOWATC                            | Should the user see the ATC and have choices on what to do?
integer *    1    LIVE_ACCESS                         | Live database access
integer *    1    TRAINING_ACCESS                        | Trainging database access
integer *    1    DOUBLE_ACCESS                       | Double Data Entry Access
date              BACKUP_DATE ('mm/dd/yyyy')            | Backup date
integer *    1    RC                                 | Return code.  -1=cancel; 0 =OK
integer *    1    MST_TRIES                          | How many times to try connecting to master
string  *    7    HTML_DARK_BLUE HTML_LIGHT_BLUE HTML_GREEN HTML_ORANGE HTML_YELLOW HTML_RED HTML_BLACK HTML_GREY HTML_WHITE
SET HTML_DARK_BLUE   ( '#0056CC' )
    HTML_LIGHT_BLUE  ( '#C1EBFF' )
    HTML_GREEN       ( '#55AC55' )
    HTML_ORANGE      ( '#F89912' )
    HTML_YELLOW      ( '#FFFF99' )
    HTML_RED         ( '#CE443E' )
    HTML_BLACK       ( '#000000' )
    HTML_GREY        ( '#EEEEEE' )
    HTML_WHITE       ( '#FFFFFF' )
value labels CONNSTAT
  (-2000) ' Bad select value in Host routine'
  (-2001) ' Specified name for database does not match'
  (-2002) ' Invalid password for database'
  (-2003) ' Password needed to attach database'
  (-2004) ' No CIRs/records found within specified restrictions'
  (-2005) ' No more CIRs/records within specified restrictions'
  (-2006) ' Maximum record count exceeded for current CIR'
  (-2008) ' Data file empty'
  (-2009) ' Invalid date string'
  (-2010) ' Invalid time string'
  (-2011) ' No. of days outside valid date range'
  (-2012) ' Data file is full'
  (-2013) ' In use flag set - run VERIFY utility'
  (-2027) ' Data file is empty after last delete'
  (-2028) ' Retrieval update mode required to add new CIR/record'
  (-2029) ' Specified record type locked or undefined'
  (-2030) ' Maximum case limit exceeded - restructure'
  (-2031) ' Data file master index overflow - restructure'
  (-2032) ' Attempted to position beyond end of data file'
  (-2033) ' Database previously opened but not closed'
  (-2034) ' Retrieval update mode required to delete case/record'
  (-2040) ' Cannot open Journal file'
  (-2041) ' Database not initialized'
  (-2042) ' Database closed - must reopen'
  (-2043) ' Invalid Database Reference'
  (-2044) ' Cannot locate update level on reload file'
  (-2045) ' Cannot close database currently used by some stream'
  (-2046) ' Cannot open reload input file'
  (-2047) ' Invalid HOST password specified to use database'
  (-2048) ' Must be DBA to Modify Schema'
  (-2049) ' Invalid lock flag specified'
  (-2053) ' Database already exists'
  (-2054) ' Update level overflow - unload and reload the database'
  (-2055) ' In use by other process'
  (-2056) ' Not found on specified disk'
  (-2057) ' Access forbidden'
  (-2058) ' Problem with open routine'
|
set SHOWATC LIVE_ACCESS TRAINING_ACCESS DOUBLE_ACCESS  (0) | just to be on the safe side
set DB# REGISTER_USER       (0)
set LOCKED_DB_ARRAY * ('0')     | No locks.  It is replaced by DBName if locked
set DB_IS_LOCKED      (0)
|
set item font DB_NAME      ,1,0,0,6,'ARIAL'|BOLD,ITALIC,UNDERL,SIZE,FONT
set image P_HEAD,  ['<GDATA4>Images\DCCIcon.bmp']
hide item DBA_NOTE
THIS_USER  = '<USERA>'
STR$1 = SIRUSER(THIS_USER)
set item ATC_FEEDBACK, 'User Name: ' + THIS_USER
|
|
| ****************      set master ip  ****************
compute MST_IP = sglobal('APPLSERVER')
| ****************      end set master ip ****************

| ****************      Make a user acknowledge somthing ****************
cif eq 1, 1
ifthen (SGLOBAL('USERA') EQ '')
. DISPLAY INFOBOX  char(13) + char(13) + 'Remember to properly close the database.' + char(13) + char(13)  +  'Thank you.'
ENDIF
cif end
| ****************      end acknowledgement ****************
|
|
<COMMENT> write 'including DB List'
include file DBSLIST
|
execute subprocedure INI_USER
execute subprocedure CHECK_USER  | returns SHOWATC = 1, plus will set the global NSECLEV for DBAs!  This is the spot to do it.
|
|
| ****************      POISON      ****************
<COMMENT> write 'Check for POISON Pill'
ifthen (fileis(dsn('POISON')) eq 1) | NO LOGINS
. set item LOCK_ALL, 'Enable Log In'
. show item DBA_NOTE
. set item DBA_NOTE, "!!!! NO LOG INS  !!!"
. ifthen (nglobal('GSECLEV') eq 1)  |database admins especially important for other Databases
.   C CONTINUE AS NORMAL
. else
.   STR$1 = "We are currently upgrading our systems."
.   DUMB_NUM# = 0
.   open (POISON) read lrecl = 500
.     loop
.       read (POISON, end = done) FILELINE$ (A200)
.       DUMB_NUM# = DUMB_NUM# + 1
.       ifthen(DUMB_NUM# eq 3 or 4)
.         STR$1 = STR$1 + char(13) + char(13) + FILELINE$
.       endif
.     end loop
.     done:
.   close (POISON)
.   display infobox STR$1
.   PQL EXIT DBMS
. endif
endif
| ****************  END POISON      ****************
|
| ****************      MASTER CHECKS ****************
<COMMENT> write 'Check Master'
ifthen (fileis(dsn('MST_BAD')) eq 1) | There is a problem
. ifthen (nglobal('GSECLEV') eq 1)  |database admins especially important for other Databases
.   display infobox 'Someone is having a problem with a database connection OR master.  Please check and clear any warnings'
. endif
endif
| ****************  END MASTER CHECKS ****************
|
|
set item UNKUSER, ''
set item LOCK_DB, "Lock " + gettxt(DB_NAME)
if (REGISTER_USER eq 0) set item UNKUSER, 'Please contact the DCC and ask for a user account'
execute subprocedure HIDEOPTIONS
execute subprocedure GET_DB#
execute subprocedure GET_MST#
execute subprocedure SHOW_CUR_DBS
execute subprocedure DISPLAY_LOCK_LIST  | Figure out what the current locks are.
|
|
| ****************      Select last used database ****************
LAST_DB_NAME = upget('database#1')
LAST_DB_NAME = reverse(LAST_DB_NAME)
LAST_DB_NAME = reverse(substr(LAST_DB_NAME, 1, (regexp(LAST_DB_NAME, '\', 1, 1)-1)))
for EACH_ITEM =  1, getnitem(DB_NAME)
. if(getitxt(DB_NAME, EACH_ITEM) eq LAST_DB_NAME) select item DB_NAME, EACH_ITEM; EXIT FOR
end for
set item LOCK_DB, "Lock " + gettxt(DB_NAME)
| ****************  END Select last used database ****************
|
|
|
c ****************      ONLY VIEW ONE DATABASE  ****************
| If somone only sees one, then try to connect directly and skip the ATC
. ifthen (getnitem (DB_NAME) eq 0)     | They do not have access to any database
.   display infobox "Please ask DB administrator to update your D.C.C. user account."
<COMMENT> write 'No DBs for this user.  EXIT SIR'
.   execute dbms 'CALL DCCPROCF.EXIT.MAIN'
. elseif (getnitem (DB_NAME) gt 1)     | Goto that database directly.  Do not show ATC
.   SHOWATC = 1
. endif
| Test to see if they can see a "training" copy too.  (that would make two database)
. if(nglobal('GSECLEV') EQ 1) SHOWATC = 1
. ifthen (SHOWATC eq 0)
.   ifthen (LIVE_ACCESS eq 1)  |THEY MUST HAVE ACCESS TO A LIVE DATABASE, NOT A COPY.
<COMMENT> write 'User sees only one database'
|     Check for Locked DB
.     execute subprocedure CX_FOR_LOCK_LIST
.     ifthen (nglobal('GSECLEV') ne 1)  | DBAs should never be locked out.
.       ifthen (DB_IS_LOCKED eq 1)
.         display infobox 'The database is being updated. Try back in a few minutes.'
.         PQL EXIT DBMS
.       endif
.     endif
.     execute subprocedure SET_MST#
.     execute subprocedure CONNECT_DB
.     execute subprocedure CHK_CONN
.     ifthen (CONNSTAT gt 0)
.       exit message
.     else
.       display infobox  "Error connecting to database. Please try back later.  Error#: " + format(CONNSTAT)
.     endif
.   endif
. endif
c ****************  END ONLY VIEW ONE DATABASE  ****************
|
|
focus item DB_NAME
|}
end initial

message ALL m_id, m_arg1, m_arg2

|{ Message
|}

ifthen (m_id eq DB_NAME )
|< DB_NAME
c connects to master and DB and either exits or stay put depending on connection.
. set item LOCK_DB, "Lock " + gettxt(DB_NAME)
. execute subprocedure CX_FOR_LOCK_LIST
. ifthen (nglobal('GSECLEV') ne 1)  | DBAs should never ever be locked out.
.   ifthen (DB_IS_LOCKED eq 1)
.     display infobox 'The database is being updated.  Try back in a few minutes.'
.     set item ATC_FEEDBACK, 'Database is locked.  Try back later'
.     NEXT MESSAGE
.   endif
. endif
. execute subprocedure GET_DB#
. execute subprocedure GET_MST#
. if (M_ARG2 ne 1) next message  |Here below is for DOUBLE CLICKS
. set item ATC_FEEDBACK, 'Connecting...........'
. execute subprocedure CHECK_USER
. ifthen (LIVE_ACCESS  = 0)
.   execute subprocedure CHECK_USER_ERR
.   next message
. endif
. ifthen (DB#C eq 101)  |IE a DB listed with no Path.  A discrepancy between DBSLIST and MSTLIST
.   display infobox 'The path to the DB could not be found.  Try again later.'
.   set item ATC_FEEDBACK, 'DB path is incorrect.'
.   next message
. endif
. execute subprocedure SET_MST#
. ifthen (MST_NUM gt 2000 and SYSTEM(38) eq 0)
.   display infobox 'Unable to start a concurrent session on ' + DSN('MASTER') + '.  Please try again later or contact the D.C.C.'
.   set item ATC_FEEDBACK, 'No Master.'
.   next message
. endif
. ifthen ((MST_NUM lt 2000) or (SYSTEM(38) = 1)) | Either it connects to master or it never had one..
.   execute subprocedure CONNECT_DB
.   execute subprocedure CHK_CONN   |returns CONNSTAT
. endif
| CHECK CONNECTION
. ifthen (CONNSTAT gt 0)  |Note they have already seen the pop up if not connected!
.   exit message
. endif

|>
next message
endif

ifthen (m_id eq DB_CON )
|< DB_CON
. execute subprocedure CX_FOR_LOCK_LIST
. ifthen (nglobal('GSECLEV') ne 1)  | DBAs should never ever be locked out.
.   ifthen (DB_IS_LOCKED eq 1)
.     display infobox 'The database is being updated.  Try back in a few minutes.'
.     NEXT MESSAGE
.   endif
. endif
. execute subprocedure GET_DB#
. execute subprocedure GET_MST#
. execute subprocedure CHECK_USER
. ifthen (LIVE_ACCESS  eq 0)
.   execute subprocedure CHECK_USER_ERR
.   next message
. endif
. ifthen (DB#C eq 101)  |IE a DB listed with no Path.  A discrepancy between DBSLIST and MSTLIST
.   display infobox 'The path to the DB could not be found.  Try again later.'
.   next message
. endif
. execute subprocedure SET_MST#
. ifthen (MST_NUM gt 2000 and SYSTEM(38) eq 0)
.   display infobox 'Unable to start a concurrent session on ' + DSN('MASTER') + '.  Please try again later or contact the D.C.C.'
.   next message
. endif
. ifthen ((MST_NUM lt 2000) or (SYSTEM(38) eq 1)) | Either it connects to master or it never had one..
.   execute subprocedure CONNECT_DB
.   execute subprocedure CHK_CONN   |returns CONNSTAT
. endif
| CHECK CONNECTION
. ifthen (CONNSTAT gt 0)  |Note they have already seen the pop up if not connected!
.   exit message
. endif
|>
next message
endif

ifthen (m_id eq DB_CLONE )
|< DB_CLONE
. DB#  = 99
. MST_NUM = 0
. DB$N(DB#) = gettxt(DB_NAME)
. DIR$(DB#) = '\\Dccmaincsfs\data5\clone\'
. write DB$N(DB#) DIR$(DB#) //
. write 'CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   CLONE   '//
. write /'- Helpful Hints' /
. write '  ~  The CLONE database is overwritten every night.'
. write '  ~  For multi-day projects use the development DB.'
. write '  ~  DO  NOT  ATTACH  MASTER'

. execute subprocedure SET_MST#   | disconnect master.
. execute subprocedure CONNECT_DB     | connect database
. execute subprocedure CHK_CONN
. exit message
|>
next message
endif

ifthen (m_id eq SIN_CON )
|< SIN_CON
c note as administrator you WILL NOT get an error messages.  Best to try the double click way
execute subprocedure GET_DB#
execute subprocedure CONNECT_DB

ifthen (CONNSTAT gt 0)
. DUMB_NUM# = setdir(DIR$(DB#))
. compute STR$1  = 'attribute prefix filename = "' + DIR$(DB#) + '"'
. execute dbms STR$1
. exit message
else
. display infobox "Did not connect.  Error#: " + format(CONNSTAT) + ' ' + pack(vallab(CONNSTAT))
endif
|>
next message
endif

ifthen (m_id eq DB_BCKUP )
|< DB_BCKUP
. BACKUP_DATE = today(0)
. execute SUBROUTINE SYSPROC.TOOLS.DATEPICK ("Backup Date", BACKUP_DATE) RETURNING (BACKUP_DATE, RC)
. if (RC eq -1) next message
. DB# =99
. MST_NUM = 0
. WINDOW CLEAR
. DB$N(DB#) = gettxt(DB_NAME)
. DIR$(DB#) = '\\Dccmaincsfs\data5\' + datec(BACKUP_DATE, 'YYYY') + '\' + datec(BACKUP_DATE, 'YYYY_MM_DD') + '_SIRXS\'
. write // 'BACKUP COPY   BACKUP COPY   BACKUP COPY   BACKUP COPY   BACKUP COPY   BACKUP COPY' /
. write // DB$N(DB#) DIR$(DB#)
. write 'FROM: ' BACKUP_DATE '   '  BACKUP_DATE '   '  BACKUP_DATE '   '  BACKUP_DATE '   '  BACKUP_DATE /
. write 'DO  NOT  ATTACH  MASTER' / 'Please, do not change the data.' / 'The DB is part of the audit trail.' /
. execute subprocedure SET_MST#   | disconnect master.
. execute subprocedure CONNECT_DB     | connect database
. execute subprocedure CHK_CONN
. exit message
|>
next message
endif

ifthen (m_id eq EXITALL )
|< EXITALL
pql exit dbms
|>
next message
endif

ifthen (m_id eq SETDPROC )
|< SETDPROC
. execute dbms "set procfile DCCPROCF"
. exit message
|>
next message
endif

ifthen (m_id eq DB_NONE )
|< DB_NONE
exit message
|>
next message
endif

ifthen (m_id eq READ_WARN )
|< READ_WARN
compute STR$1 = 'EDITFILE "' + dsn('MST_BAD') + '"/clear'; EXECUTE DBMS STR$1
|>
next message
endif

ifthen (m_id eq CLEAR_WARN )
|< CLEAR_WARN
ifthen (fileis(dsn('MST_BAD')) ne 1)
. display infobox "Sorry the file was not found"
. next message
endif
. open (MST_BAD) read  lrecl = 500
.   open (MST_FIXED) append lrecl = 500
.     loop
.       read (MST_BAD, end = done) FILELINE$ (A200)
.       write (MST_FIXED) FILELINE$ (A200)
.     end loop
.     done:
.   close (MST_FIXED)
. close (MST_BAD)

. YESNOVAR = DELFILE (dsn('MST_BAD'))
. ifNOTthen (YESNOVAR eq 0)
.   display infobox "There was an error deleting the file.  Please delete the file by hand"
.   display infobox ["path is:" + dsn('MST_BAD')]
. endif
|>
next message
endif

ifthen (m_id eq LOCK_DB )
|< LOCK_DB
| check master for users, lock database so no more users can get in.
. for EACHITEM = 1, getnitem(LOCK_LIST)
.   ifthen (getitxt(LOCK_LIST, EACHITEM) eq gettxt(DB_NAME))
.     display infobox "Look, it is already Locked."
.     next message
.   endif
. end for
. execute subprocedure GET_MST#
. execute subprocedure SET_MST#
. ifthen ( system(69) gt 0)
.   STR$1 = 'Master ' + MST_IP  + ':' + format(MST_NUM) + ' is attached to ' + format(system(69)) + ' DBs: ' + char(13)
.   for EACH_DB = 1,  system(69)
.     STR$1 = STR$1 + char(13)+ getmdbn(EACH_DB)
.   end for
.   display infobox STR$1
. endif
. ifthen (system(68) gt 1)
.   STR$1 = 'Master ' + MST_IP + ':' + format(MST_NUM) + ' has ' + format(system(68)) + ' Clients' + char(13)
.   for EACH_CLIENT = 1, system(68)
.     STR$1 = STR$1 + char(13) + getmcadd(getmclid(EACH_CLIENT))
.     if (getmclst(EACH_CLIENT) ne 0) STR$1 = STR$1 +  '  at  ' + timec(getmclst(EACH_CLIENT), 'hh:mm:ss')
.   end for
.   display infobox STR$1
. endif

. execute dbms "CALL DCCPROCF.BASE.MSTCLEAR"


. STR$1 =  pad(gettxt(DB_NAME),' ', 34, 34) + 'LOCKED   ' + datec(today(0), 'mm/dd/yyyy')  +'  ' + timec(now(0), 'hh:mm ') + THIS_USER

. display textbox "Reason?" response YESNOVAR, STR$2
. if (YESNOVAR eq -1) next message | canceled
. if (exists(STR$2) eq 1) STR$1 = STR$1 + '  Reason ' + STR$2
. open  (LOCK_DBS) append iostat = FILEIOSTAT lrecl = 300
.   ifthen (FILEIOSTAT eq 0)
.     write (LOCK_DBS) STR$1
.   else
.     display infobox 'Error locking database.  DB IS NOT LOCKED.'
.   endif
. close (LOCK_DBS)
. execute subprocedure DISPLAY_LOCK_LIST
|>
next message
endif

ifthen (m_id eq LOCK_READ )
|< LOCK_READ
. STR$1 = "EDITFILE '" + dsn('LOCK_DBS') + "'"
. execute dbms STR$1
|>
next message
endif

ifthen (m_id eq LOCK_ALL )
|< LOCK_ALL
. ifthen (fileis(dsn('POISON')) eq 0)
.   display yncbox "Stop everyone from signing in?" response YESNOVAR
.   if (YESNOVAR ne 1) next message  | do not continue
.   STR$1 =  'We expect to be back on-line in 1 hour,'
.   display textbox "When do you expect to be back on line?" response YESNOVAR, STR$1
.   while (exists(STR$1) eq 0)
.     display textbox "When do you expect to be back on line?" response YESNOVAR, STR$1
.   end while
.   set item LOCK_ALL, "Log in Disabled"
.   open (POISON) write
.     write (POISON) 'Nobody can sign in until this file is deleted'
.     write (POISON) 'Created by ' THIS_USER | <USERA> ' [upper(getenv('USERNAME'))]
.     write (POISON) 'Started ' [datec(today(0), 'Www. mm/dd/yyyy') ] '  at  '[timec(now(0), 'hh:mm pp') ]
.     write (POISON) STR$1
.   close (POISON)
.   show item DBA_NOTE
.   set item DBA_NOTE, "!!!!   NO LOG INS   !!!!!!"

.   display infobox "All access through the ATC have been disabled.  Nobody can sign in." + char(13) + char(13)
                    + "If a user is in a database, they may stay in, but once out, they may not log back in."
. else
.   display yncbox "Allow everyone to sign in through the ATC?" response YESNOVAR
.   ifthen (YESNOVAR eq 1)
.     YESNOVAR = DELFILE (dsn('POISON'))
.     ifthen (YESNOVAR eq 0)
.       display infobox "Everyone may now sign in."
.       set item LOCK_ALL, "Log in Enabled."
.       set item DBA_NOTE, ""
.     else
.       display infobox "There was an error deleting the file. It still exists. No sign ins allowed"
.       display infobox ["path is:" + dsn('POISON')]
.       set item LOCK_ALL, "Log in Disabled."
.       set item DBA_NOTE, "!!!!!   NO LOG INS   !!!!!!"
.     endif
.   else
.     display infobox "Users are not allowed in."
.     set item LOCK_ALL, "Log in Disabled."
.     set item DBA_NOTE, "!!!!!   NO LOG INS   !!!!!!"
.   endif
. endif
|>
next message
endif

ifthen (m_id eq LOCK_LIST )
|< LOCK_LIST
. if(M_ARG2 ne 1) NEXT MESSAGE
. STR$1 = pad(gettxt(LOCK_LIST), ' ', 34, 34) + 'UNLOCKED ' + datec(today(0), 'mm/dd/yyyy')   + '  ' + timec(now(0), 'hh:mm ') + THIS_USER
. open  (LOCK_DBS) append  iostat =  FILEIOSTAT lrecl = 200
.   ifthen (FILEIOSTAT eq 0)
.     write (LOCK_DBS) STR$1
.     write 'Users can sign in: ' STR$1
.   else
.     display infobox 'Unable to remove lock.  DB IS STILL LOCKED'
.   endif
. close (LOCK_DBS)
. execute subprocedure DISPLAY_LOCK_LIST  | Figure out what the current locks are.
|>
next message
endif

ifthen (m_id eq B_DEV_DB )
|< B_DEV_DB
c Double Data Entry This is how it was done.
. DB#  = 99
. MST_NUM = 0
. MST_NUM = 0
. DB$N(DB#) = gettxt(DB_NAME)
. DIR$(DB#) = '\\Dccmaincsfs\data5\development\'
. for EACH_LINE = 1, 5
.   write 'Development     Development      Development     Development      Development     Development'
. end for
. ifnot (fileis( DIR$(DB#) + DB$N(DB#)  + '.sr1' ) eq 1) display infobox "Devlopment DB is not there"; next message
. write // 'This DB is updated on occassion at developer''s/programmer''s discretion.'//

. write  '- Helpful Hints' /
. write  '  ~  Before modifying this DB, please contact the primary DBA' /
. write  '  ~  Copy over the clone database from time to time to refresh everything' /
. write  '  ~  You can copy specific files such as the SR1, SR2, SR3 files.'
. write  '  ~  You could leave the current SR4 in place.' /
. write  '  ~  This DB will not be overwritten during backups.'
. write  '  ~  It is perfectly fine to work on a project for days or even weeks without it getting over written.' /
. write  '  ~  Multi User environment is not advised'//
. write  '  ~  DB: ' DB$N(DB#)  '    Path:  'DIR$(DB#)
. execute subprocedure SET_MST#   | disconnect master.
. execute subprocedure CONNECT_DB | connect database
. execute subprocedure CHK_CONN
. exit message
|>
next message
endif

ifthen (m_id eq USERSTATS )
|< USERSTATS
.   execute dbms "call DCCPROCF.DIALOG.USER_STATS"      |DCC
|>
next message
endif

if (m_id eq 0) exit message

end message


end dialog
|{ Exit
| append log in file
execute subprocedure WRITELOGIN
|
ifthen (CONNSTAT gt 0) |connected to a database.
. compute CHK_PATH = '@' + pack(upper(dsn('prefix'))) + '@'
. compute SIR_PATH = upper(dsn('sysproc'))
. compute HTML_COLOR = HTML_GREEN
. ifthen (SIR_PATH eq upper(appdir(0)) + 'SIRPROC.SRP' or '\\PIDATA\SIR2002\SIRPROC.SRP') | Make sure that the database is on the G drive.
.   open (DBSLIST) read lrecl = 300
.     loop
.       read (DBSLIST, end = done) DB_DSN (A300)
.       compute DB_DSN = pack(upper(trim(DB_DSN)))
.       ifthen (pattern(DB_DSN, CHK_PATH) eq 1)
.         compute HTML_COLOR = HTML_YELLOW  |yellow  everything is right
.         exit loop
.       endif
.     end loop
.     done:
.   close (DBSLIST)
. endif
. if (pattern(upper(CHK_PATH), upper('@development@')) eq 1) HTML_COLOR  =  HTML_GREY |Light Grey for development DB
. ifthen ( pattern( upper( CHK_PATH), '@DEVELOPMENT@') eq 1 )
.   HTML_COLOR = HTML_GREY
. elseif ( pattern( upper( CHK_PATH), '@\CLONE\@') eq 1 )
.   HTML_COLOR = HTML_RED
. elseif ( pattern( upper( CHK_PATH), '@SIRXS\@') eq 1 )
.   HTML_COLOR = HTML_ORANGE
. endif
. STR$1 = '<body bgcolor="' + HTML_COLOR + '">'
. window output  STR$1 html  |  BACKGROUND color
c . window clear
. write''
. write''
. write ['                 Welcome to the ' + pack(dbname(0)) + ' database ']
. execute dbms "call DCCPROCF.SYSTEM.ALLRECS"
. ifthen (nglobal('GSECLEV') ne 1)
.   DUMB_NUM# = WINMOVE (550, 1, 0, 0)
. end if
c CALL DATA ENTRY NAVIGATE.MAIN OR FILE TRANSFER COPY OR ANYTHING ELSE THAT CITRIX.START DICTATES.
. ifthen (Nglobal('GSECLEV') eq 3)
.   ifthen (meminfo('CITRIX.START:T', 1) eq 1)
.     execute dbms "CALL CITRIX.START"  |DCC
.   else
.     display infobox "CITRIX.START IS NOT DEFINED"  |DCC
.     PQL EXIT DBMS   | if this is not defined, we don't want them in, but in a blank SIR session.
.   endif
. elseif(meminfo('DIALOG.MAINMENU:T', 1) eq 1)   | leave so old backup copies still work.
.   execute dbms "CALL DIALOG.MAINMENU"  |DCC
. elseif (meminfo('NAVIGATE.MAIN:T',  1) eq 1)
.   ifNOT (Nglobal('GSECLEV') eq 1) execute dbms "CALL NAVIGATE.MAIN"
. else
.   ifthen (Nglobal('GSECLEV') eq 1)
.     write 'use the drop down menu to call DCCPROCF.NAVIGATE.MAIN'
.   else
.     execute dbms "CALL DCCPROCF.NAVIGATE.MAIN"
.   endif
. endif
. execute dbms "set procfile sir014"
else
. IFNOT (NGLOBAL('GSECLEV') EQ 1) PQL EXIT DBMS
endif
|}
|{ Footer
|
|
subprocedure SHOW_CUR_DBS
<COMMENT> write 'Show already connected DBs'
c list all DBs
. ifthen (system(40) eq 0)
.   hide item CUR_DBS
.   hide item CUR_DBS$
. else
.   show item CUR_DBS
.   show item CUR_DBS$
. endif
. for EACH_DB = 1, SYSTEM(40)
.   append item CUR_DBS, dbname(EACH_DB)
. end for
end subprocedure
|
|
subprocedure GET_DB#  |instead of using gettxt this allows more flexibility and consistency
c Get the DB name and number
<COMMENT> write 'Get the database reference #'
. if (getnitem(DB_NAME) eq 0) exit subprocedure | NO DBS to cycle through
. for DB# = 1, 100                                |101 means DB not found in list
.   if (gettxt(DB_NAME) eq DB$N(DB#)) exit for
. end for
. ifthen (DB# ne 101)
.   set item DB_PATH, DIR$(DB#)
. else
.   set item DB_PATH, 'Incorrect Path'
. endif
end subprocedure
|
|
subprocedure GET_MST#
c Attach Master if needed   MST_NUM = 0 = no master
<COMMENT> write 'Get the reference # for master'
. compute MST_NUM = 0                                    |Safe side is NO master
. open (MSTLIST) read | / dsnvar = MSTLIST$
.   loop
.     read (MSTLIST, end = done) FILELINE$ (A100)              | 1. Cycle through the list of authorized users...
.     ifthen (trimlr(sbst(FILELINE$, 1, 17)) eq gettxt(DB_NAME))      | 2. Check the list for DB names that match this DB...
.       MST_NUM = numbr(sbst(FILELINE$, 36, 4))
.     endif
.   end loop
.   done:
. close (MSTLIST)
. if (exists(MST_NUM) eq 0) MST_NUM = 0
. ifthen (MST_NUM eq 0)
.   set item MST_NUM#,  ''
. elseif (MST_NUM gt 1999)
.   set item MST_NUM#, MST_IP + ':' + format(MST_NUM)
. endif
end subprocedure
|
|
subprocedure CONNECT_DB
<COMMENT> write 'Connect to the database'
. set item ATC_FEEDBACK, 'Connecting ' + DB$N(DB#)
. while (system(40) GT 0)
.   compute DB_NAME$ = pack(dbname(0))
.   ifthen (DB_NAME$ eq DB$N(DB#))
.     display infobox 'You are already connected to the ' + DB$N(DB#) + char(13) + 'in:  ' + DIR$(DB#)
.     compute CONNSTAT = 1
.     EXIT SUBPROCEDURE
.   endif
.   display yesnobox ['Do you want to disconnect from '  + DB_NAME$  + ' first'] response YESNOVAR
.   ifthen (YESNOVAR eq 1)
.     pql disconnect database DB_NAME$
.     set item ATC_FEEDBACK, 'Disconnected: ' + DB_NAME$
.   else
.     EXIT WHILE
.   endif
. end while
|
. pql connect database DB$N(DB#)
              security "RIPTIDE", "", ""
              prefix   DIR$(DB#)
              iostat   CONNSTAT
. DUMB_NUM# = globals('GDBNAME', DB$N(DB#))
end subprocedure CONNECT_DB
|
|
subprocedure CHK_CONN
| CHECK to see if connected and set counting DB globals
<COMMENT> write 'Check the connection to the database. Set prefix'
. set item ATC_FEEDBACK, 'Checking Database Connection.'
. DUMB_NUM# = upset('database#1', DIR$(DB#) + DB$N(DB#))
. ifthen (CONNSTAT gt 0)
.   set item ATC_FEEDBACK, 'Succesfully connected: ' + DB$N(DB#)
.   DUMB_NUM# = setdir(DIR$(DB#))
.   STR$1 = 'attribute prefix filename = "' + DIR$(DB#) + '"'
.   execute dbms STR$1
.   execute subprocedure WRITE_USER_LOG
. else
.   ifthen (CONNSTAT eq -2041)
.     DUMB_NUM# = setdir(DIR$(DB#))
.     STR$1 = 'attribute prefix filename = "' + DIR$(DB#) + '"'
.     execute dbms STR$1
.   elseif (CONNSTAT eq -9004)
.     display infobox ['Unable to connect to Database. Try Again Later. Status: ' + format(CONNSTAT)]
.     set item ATC_FEEDBACK, 'Unable to connect: ' + format( CONNSTAT )
.     execute subprocedure REPORT_DBERROR
.   else
.     display infobox ['Unable to connect to Database. Try Again Later. Status: ' + format(CONNSTAT) + ', ' + pack(vallab(CONNSTAT))]
.     set item ATC_FEEDBACK, 'Unable to connect: ' + format( CONNSTAT )
.     execute subprocedure REPORT_DBERROR
.   endif
. endif
end subprocedure CHK_CONN
|
|
subprocedure SET_MST#
| play it on the safe side, if a master is connected already disconnect all databases from current SIR session.  Better safe than sorry.
<COMMENT> write 'Connect master. If a master was already attached, disconnect it'
. ifthen (system(38) eq 1)  |Master is handing the session.  If differnet MST# disconnet all connected DBs to solve master issues
.   set item ATC_FEEDBACK, 'Master is handling connection.'
.   if(system(68) ge 1)  execute dbms "COPY DIFFERENCE FILE"  | no one is in, so DFC
.   execute dbms "CALL DCCPROCF.BASE.MSTCLEAR" |Start with no master
.   set item ATC_FEEDBACK, 'Master disconnected.'
.   while (system(40) gt 0)
.     DB_NAME$ = pack(DBNAME(0))
.     set item ATC_FEEDBACK, 'You were connected to: ' + DB_NAME$
.     pql disconnect database DB_NAME$
.   end while
. endif
| Now try to connect Master if applicable
. ifthen (MST_NUM gt 2000)
.   STR$1 = 'SET MASTER ' + MST_IP + ':' + format(MST_NUM)  | HARD CODED
.   MST_TRIES = 0 | try to connect master three times
.   while (system(38) eq 0)
.     execute dbms STR$1
.     ifthen (system(38) eq 0)
.       MST_TRIES = MST_TRIES  + 1
.       wait 3
.       set item ATC_FEEDBACK, 'Attempts to connect to master: ' + format( MST_TRIES )
.     else exit while
.       set item ATC_FEEDBACK, 'Master Connected ' + MST_IP + ':' + format(MST_NUM)
.     endif
.     if (MST_TRIES ge 3) exit while | three tries your out.
.   end while
.   wait 10  | necessary before trying DB.  It helps.
. endif
. ifthen (MST_NUM gt 2000)
.   ifthen (system(38) eq 0)
.     set item ATC_FEEDBACK, 'Max attempts to master: ' + format( MST_TRIES )
.     open (MST_BAD) append lrecl = 500
.       STR$1 = 'ATC Tried MST on ' + MST_IP + ': ' + format(MST_NUM)  + '  '  + datec(today(0), 'mm/dd/yyyy') + '  ' + pad(timec(now(0), 'hh:mm:ss'), ' ', 12, 12) + THIS_USER + ' db:' + DB$N(DB#)
.       write (MST_BAD) STR$1
.     close (MST_BAD)
.   else
.     set item MST_NUM#, gettxt(MST_NUM#) + ' Connected'
.   endif
. endif
end subprocedure SET_MST#
|
|
subprocedure WRITELOGIN
. STR$1 = pad('<STARTTIME>',' ', 12, 12) + pad(THIS_USER, ' ', 20, 20) +  pad(dbname(0), ' ', 20, 20)
. ifthen (system(38) eq 1)   |  master
.   for EACH_CLIENT = 1, system(68)    | Number of clients attached to master
.     ifthen ( getmcadd(getmclid(EACH_CLIENT)) eq dsn('CLIENT'))
.       compute STR$1 = STR$1 + pad(getmcadd(getmclid(EACH_CLIENT)), ' ', 20, 20)   | Master client name attached to the end.
.       exit for
.     endif
.   end for
. endif
. open (LOGINS)  append IOSTAT =  FILEIOSTAT lrecl = 600
.   write (LOGINS) STR$1
. close (LOGINS)
. ifthen (pack(upper(getenv('username'))) eq 'GNEILS') | a little helpful info
C .   write 'signed in permission level ' [nglobal('GSECLEV')]
. endif
end subprocedure
|
|
|
subprocedure INI_USER
<COMMENT> write 'Read the user list. See if user is there'
. remove all DB_NAME
. set item ATC_FEEDBACK, 'Checking User Info.'
. open (MSTLIST) read
.   loop
.     read (MSTLIST, end = DONE) FILELINE$ (A100)
.     ifthen (sbst(FILELINE$, 1, 1) ne '|')
.       ifthen (trim(sbst(FILELINE$, 44, 15)) eq THIS_USER)        |The Master List explicitly lists all users and their DBs.
.         DB_NAME$ = trim(sbst(FILELINE$, 1, 18))
.         append item DB_NAME, DB_NAME$
.         REGISTER_USER = 1
.         set item ATC_FEEDBACK, 'Welcome ' + THIS_USER
.       endif
.     endif
.   end loop
.   DONE:
. close (MSTLIST)
end subprocedure INI_USER
|
subprocedure HIDEOPTIONS
<COMMENT> write 'Hide certain buttons and list for different user levels'
. ifthen (nglobal('GSECLEV') ne 1)
.   disable item DB_NONE      ; hide item DB_NONE
.   disable item LOCK_READ    ; hide item LOCK_READ
.   disable item READ_WARN    ; hide item READ_WARN
.   disable item CLEAR_WARN   ; hide item CLEAR_WARN
.   disable item LOCK_ALL     ; hide item LOCK_ALL
.   disable item LOCK_DB      ; hide item LOCK_DB
.   disable item LOCK_LIST    ; hide item LOCK_LIST
.   disable item LOCK_LAB     ; hide item LOCK_LAB
.   disable item DB_CLONE     ; hide item DB_CLONE
.   disable item B_DEV_DB     ; hide item B_DEV_DB
.   disable item USERSTATS    ; hide item USERSTATS
.   hide item DB_PATH
.   hide item MST_NUM#
.   hide item CUR_DBS
.   hide item CUR_DBS$
.   hide item SETDPROC
.   hide item SIN_CON
.   hide item DB_BCKUP
.   hide item DB_CON
.   hide item LINE1AA
.   hide item LINE2AA
.   hide item LINE3AA
.   hide item LINE4AA
.   hide item LINE5AA
.   hide item LINE6AA
.   for EACH_ITEM  = 1, 80
.     disable menuitem EACH_ITEM
.   end for
.   for EACH_ITEM = 1100, 1200  |DBA options
.     disable menuitem EACH_ITEM
.   end for
. endif
end subprocedure
|
|
subprocedure DISPLAY_LOCK_LIST
| basic logic.  If a database is lock and then unlocked, the unlocked will always be after the lock.  So basically it flips between locked and unlocked to finally decide the final outcome.
<COMMENT> write 'Display locked DBs.'
. remove all LOCK_LIST
. open (LOCK_DBS) read lrecl = 300 iostat =  FILEIOSTAT
.   ifthen (FILEIOSTAT eq 0)
.     loop
.       read (LOCK_DBS, end = done) FILELINE$ (A300)              | 1. Cycle through locked databases
.       CHECK_DBNAME_LOCK = trimlr(substr(FILELINE$, 1, 32))
.       CHECK_DBSTAT_LOCK = trimlr(substr(FILELINE$, 35, 8))
.       ifthen (CHECK_DBSTAT_LOCK eq 'LOCKED')
.         for EACH_LOCKED_DB = 1, 32
.           if (LOCKED_DB_ARRAY (EACH_LOCKED_DB) EQ CHECK_DBNAME_LOCK) EXIT FOR
.           ifthen (LOCKED_DB_ARRAY (EACH_LOCKED_DB) eq '0')
.             LOCKED_DB_ARRAY (EACH_LOCKED_DB) = CHECK_DBNAME_LOCK
.             exit for | assigned first available spot for the database name
.           endif
.         end for
.       elseif (CHECK_DBSTAT_LOCK eq 'UNLOCKED')  | do something to mark it as unlocked
.         for EACH_LOCKED_DB = 1, 32
.           ifthen (LOCKED_DB_ARRAY (EACH_LOCKED_DB) eq CHECK_DBNAME_LOCK )
.             LOCKED_DB_ARRAY (EACH_LOCKED_DB) = '0'
|             note: that there is no "exit for".  I want to cycle through everything so I don't miss one accidentaly.
.           endif
.         end for
.       endif
.     end loop
.     done:
.   else
|.     display infobox 'Cannot open file to lock database' + char(13) + LOCK_DBS
.   endif
. close (LOCK_DBS)
. for EACH_LOCKED_DB = 1, 32
.   ifthen (LOCKED_DB_ARRAY (EACH_LOCKED_DB) ne '0')
.     append item LOCK_LIST, LOCKED_DB_ARRAY (EACH_LOCKED_DB)
.   endif
. end for
. ifthen (getnitems(LOCK_LIST) eq 0) hide item LOCK_LIST; hide item LOCK_LAB
. else show item LOCK_LIST; show item LOCK_LAB
. endif
end subprocedure
|
|
subprocedure CX_FOR_LOCK_LIST
<COMMENT> write 'Check for locked DBs.'
. DB_IS_LOCKED = 0
. for EACH_LOCKED_DB = 1, getnitem(LOCK_LIST)
.   ifthen (getitxt(LOCK_LIST, EACH_LOCKED_DB) eq gettxt(DB_NAME))
.     DB_IS_LOCKED = 1
.   endif
. end for
end subprocedure
|
|
subprocedure CHECK_USER
<COMMENT> write 'See user permissions'
. LIVE_ACCESS = 0
. TRAINING_ACCESS = 0
. DOUBLE_ACCESS = 0
| add in double data entry button at some time
. SHOWATC = 0
. open (MSTLIST) read | / dsnvar = MSTLIST$
.   loop
.     read (MSTLIST, end = done) FILELINE$ (A100)                  | 1. Cycle through the list of authorized users.
.     ifthen (sbst(FILELINE$, 1, 1) ne '|')
c write [sbst(FILELINE$, 64, 1)] [sbst(FILELINE$, 66, 1)] [sbst(FILELINE$, 68, 1)] 15t [numbr(trimlr(sbst(FILELINE$, 41, 2)))]
.       ifthen (trim(sbst(FILELINE$, 44, 15)) eq THIS_USER)         | Correct user in master list
.         if(sbst(FILELINE$, 66, 1) eq 'T') SHOWATC = 1            | Any Training Database.  Neccessary to know at start up.  If no training database and user has access to 1 db, it will exit out and connect them to their database.
.         if(sbst(FILELINE$, 68, 1) eq 'D') SHOWATC = 1            | Any Double Data Entry Database.  Neccessary to know at start up.  If no training database and user has access to 1 db, it will exit out and connect them to their database.
.         ifthen(gettxt(DB_NAME) eq trim(sbst(FILELINE$, 1, 17)))   | Selected database
.           DUMB_NUM# =  globaln('GSECLEV', numbr(trimlr(sbst(FILELINE$, 41, 2))))     |This global is set to be used by any DB that needs it
.           if(sbst(FILELINE$, 64, 1) eq 'L') LIVE_ACCESS = 1        | Live Database access
.         elseif(gettxt(DB_NAME) eq 'BIOMARKERS')   | Selected database
.           DUMB_NUM# =  globaln('GSECLEV', numbr(trimlr(sbst(FILELINE$, 61, 2))))     |This global is set to be used by any DB that needs it
.           if(sbst(FILELINE$, 64, 1) eq 'L') LIVE_ACCESS = 1        | Live Database access
.         endif
.       endif
.     endif
.   end loop
.   done:
. close (MSTLIST)
. IF(0 eq LIVE_ACCESS AND TRAINING_ACCESS AND DOUBLE_ACCESS) display infobox "Sorry you don't have access to any version of " + gettxt(DB_NAME)
end subprocedure
|
|
subprocedure WRITE_USER_LOG
. USER_LOG = '<GDATA4>Users\' + THIS_USER + '.csv'
. ifthen (fileis(USER_LOG) eq 0)
.   open (USER_LOG) dsnvar = USER_LOG write lrecl = 200
.     write (USER_LOG) 'Date,Database,Start,End'
.   close (USER_LOG)
. endif
. open (USER_LOG) dsnvar = USER_LOG write append lrecl = 200
.   write (USER_LOG) [datec(today(0), 'MM/DD/YYYY') + ',' + dbname(0) + ',' + timec(now(0), 'HH:MM:SS') + ',']
. close (USER_LOG)
end subprocedure
|
|
subprocedure CHECK_USER_ERR
. ifthen(TRAINING_ACCESS eq 1)
.   display infobox 'If you would like the training database copy, please click on Training.'
. elseif(DOUBLE_ACCESS eq 1)
.   display infobox 'If you would like the Double Data Entry database, please click on Double Data Entry.'
. elseif(LIVE_ACCESS eq 0)
.   display infobox 'You do not have access to that database.'
.   set item ATC_FEEDBACK, 'Sorry, you do not have access to the live database.'
. else
.   display infobox 'Please contact the DCC.  Err# 8'  | Make sure they are marked in the DCC DB as having access to the DDE database
. endif
end subprocedure
|
|
subprocedure REPORT_DBERROR
. set item ATC_FEEDBACK, 'Reporting connection error.'
. open (MST_BAD) append lrecl = 500
.   STR$1 = 'ATC Tried,'
.   if (exists(DIR$(DB#)) eq 1 ) STR$1 = STR$1 + DIR$(DB#)
.   STR$1 = STR$1  + ','
.   if (exists(DB$N(DB#)) eq 1 ) STR$1 = STR$1 + DB$N(DB#)
.   STR$1 = STR$1 + ','
.   STR$1 = STR$1 + datec(today(0),'mm/dd/yyyy')
.   STR$1 = STR$1 + ', '
.   STR$1 = STR$1 + pad(timec(now(0), 'hh:mm:ss'), ' ', 12, 12)
.   STR$1 = STR$1 + ', '
.   if (exists(THIS_USER) eq 1 ) STR$1 = STR$1 +  THIS_USER
.   STR$1 = STR$1  + ','
.   if (exists(CONNSTAT) eq 1 ) STR$1 = STR$1 +  format(CONNSTAT)
.   STR$1 = STR$1  + ','
.   if (exists(vallab(CONNSTAT)) eq 1 ) STR$1 = STR$1 + pack(vallab(CONNSTAT))
.   STR$1 = STR$1  + ','
.   STR$1 = STR$1 +  ' Release: <SIRID> and Version: <SIRVER>'
.   write (MST_BAD) STR$1
. close (MST_BAD)
end subprocedure
end program
|}
END PROCEDURE
