PROCEDURE      TOOLS.EXPORT_TO_MYSQL:T  (157889,51982)  |Last amended Jan 26, 2015,14:26:22
c TRANSFER SIR DATA TO A MYSQL DATABASE.

C COMPILE NECESSARY TOOLS
CALL TOOLS.CHECK_RESERVED_WORDS

PRINT BACK OFF
C PRINT BACK REMARKS

GLOBAL username    = dcd
GLOBAL password    = dcd
global redcap      = yes
GLOBAL new         = no
GLOBAL STOP_REC    = 6 | DON'T SET THIS TO GET ALL RECORD TYPES
GLOBAL LARAVEL     = yes | add specif stuff for Laravel Framework
global NULL_VALUE  = '' | NULL
global date_format = 'mm/dd/yyyy'  |  'yyyy-mm-dd'
global time_format = 'hh:mm'    |  'hh:mm:ss'
GLOBAL G_CONTINUE  = 0  | 0=Do Not Continue   1=Continue
global CASE_RESTRICTION   = ' COUNT = 25'
| global CASE_RESTRICTION = 'SAMPLE_SIZE = 1'
global WINDOWS_MACHINE = 1
global LINE_TERMINATOR = '\n'
global TABLE_PREFIX = 'crf_'

C -------------------------------------------------------------------------------------------------------------
C ----LINE TERMINATOR and file endinds-------------------------------------------------------------------------
C
PROGRAM
. integer * 1 T
. string  * 4 FILE_ENDING  | "csv, tab"
. T = globaln ( 'CASE_SEEDER', NOW(0) )
. IFTHEN  ( 0<WINDOWS_MACHINE> EQ 1 )
.   T = globals ( 'LINE_TERMINATOR', '\r\n' )  | WINDOWS END OF LINE.  change according to your system.
.   WRITE 'PATHS TO WINDOWS FILE WILL BE HAVE THE BACKSLASH (SQL KEYWORD) ESCAPED.  LOOK FOR DOUBLE BACKSLASHES '/
. ENDIF

| set the file ending and everything else will be set.  |add new options when needed.
. FILE_ENDING = lower( "csv" )
.
. IFTHEN  ( lower( FILE_ENDING ) EQ 'tab' )
.   T = globals ( 'FILE_ENDING', 'tab' )
.   T = globals ( 'DELIMINATOR', char(9) )  | tab
.   T = globals ( 'SQL_DELIMINATOR', '\t' )  | tab
.   T = globals ( 'PQL_DELIMINATOR', 'char(9)' )  | tab

. elseif   ( lower( FILE_ENDING ) EQ 'csv' )
.   T = globals ( 'FILE_ENDING', 'csv' )
.   T = globals ( 'DELIMINATOR', char(44) )
.   T = globals ( 'SQL_DELIMINATOR', ',' )
.   T = globals ( 'PQL_DELIMINATOR', 'char(44)' )
. else
.   write /////'  !!!!! A BIG MISTAKE HAPPENED.  PLEASE CHOOSE A FILE ENDING  !!!!!  ///'
. ENDIF
end program


C -------------------------------------------------------------------------------------------------------------
C ---   report back settings ----------------------------------------------------------------------------------
Program
write 'YOUR SETTINGS ARE' /
      5t 'SEED = <CASE_SEEDER>' /
      5t 'SAMPLE SIZE = <SAMPLE_SIZE>'  /
      5t 'USERNAME = <USERNAME>' /
      5t 'PASSWORD = <PASSWORD>' /
      5t 'NEW = <NEW> ' /
      5t 'Laravel= <laravel> ' /
      5t 'CASE_RESTRICTION = <CASE_RESTRICTION>' /
      5t 'WINDOWS MACHINE  = <WINDOWS_MACHINE>' /
      5t 'LINE TERMINATOR  = <LINE_TERMINATOR>' /
      5T 'FILE_ENDING= <FILE_ENDING>' /
      5T 'DELIMINATOR= <DELIMINATOR>' /
      5T 'SQL_DELIMINATOR = <SQL_DELIMINATOR>' /
      5T 'PQL_DELIMINATOR = <PQL_DELIMINATOR>' /
      5t 'redcap= <redcap>' / /

end program

C -------------------------------------------------------------------------------------------------------------
C --- create OUTPUT FOLDER     --------------------------------------------------------------------------------
c
program CRWARN
. string  *  250   OUTPUT_DIR DIR$
. string  *  250   LARAVEL_DIR
. string  *  250   FILE_PATH FILE_NAME
. STRING  *    6   FILE_EXT
. INTEGER *    2   EACH_CHAR
. integer *    4   PASSFAIL
. string  *  300   DBMS_LINE

. OUTPUT_DIR = dsn( 'prefix' )  +  'to_mysql\'
. execute SUBROUTINE SYSPROC.TOOLS.FILENAME ( OUTPUT_DIR ) RETURNING ( FILE_PATH, FILE_NAME, FILE_EXT )

. for EACH_CHAR = 1, len(  FILE_PATH  )
.   IF (  sbst(  FILE_PATH , EACH_CHAR, 2 ) = ':' ) NEXT FOR  | EXCEPTION FOR c:\
.   IF (  FILEIS(  SBST(  FILE_PATH, 1, EACH_CHAR )  ) EQ -1 ) NEXT FOR | FOLDER ALREADY EXISTS
.   IFTHEN (  sbst( FILE_PATH , EACH_CHAR, 1 ) EQ "\"  )
.     DIR$ = SBST( FILE_PATH, 1, EACH_CHAR )
.     PASSFAIL = makedir( DIR$ )
C .     if ( PASSFAIL  EQ -1 ) EXIT FOR
.   ENDIF
. end for

. ifthen ( FILEIS( OUTPUT_DIR  ) EQ -1  )
.   write 'Excellent: Output folder created: ' OUTPUT_DIR
. else
.   write 'FAILED TO MAKE NECESSARY OUTPUT FOLDER: ' OUTPUT_DIR
C .   pql exit dbms
. endif
. DBMS_LINE = 'set attribute output_dir = "' + OUTPUT_DIR + '"'
. execute dbms DBMS_LINE

. ifthen ( sglobal( 'LARAVEL' ) eq 'yes' )
.   LARAVEL_DIR = OUTPUT_DIR + 'Laravel\'
.   PASSFAIL = makedir( LARAVEL_DIR )
.   PASSFAIL = makedir( LARAVEL_DIR + 'app\' )
.   PASSFAIL = makedir( LARAVEL_DIR + 'app\models\' )
.   PASSFAIL = makedir( LARAVEL_DIR + 'app\controllers\' )
.   PASSFAIL = makedir( LARAVEL_DIR + 'app\views\' )
C WRITE DOUBLE CHECK LATER
C .   write / 'ERROR: FAILED TO MAKE LARAVEL DIRECTORY: ' LARAVEL_DIR PASSFAIL
. endif

end program

C -------------------------------------------------------------------------------------------------------------
C ---  create database schema and keys constraints  -----------------------------------------------------------

program
. STRING  *  300   CREATE_DB_FILE
. string  *  300   REDCAP_FILE
. string  * 2000   REDCAP_CSV_LINE
. string  * 2000   REDCAP_VALLABS
. STRING  *  300   CREATE_CONSTRAINT_FILE
. INTEGER *    4   IO_FEEDBACK
. INTEGER *    4   Z_DUMMY
. INTEGER *    4   STOP_REC
. STRING  *  300   CHECK_WORD
. STRING  *  300   CLEAN_WORD
. STRING  *  300   CHECK_FILE
. integer *    1   THIS_VTYPE
. STRING  *   32   THIS_VAR_SQL_TYPE
. STRING  *   32   THIS_VAR_REDCAP_TYPE
. string  *   32   THIS_VARMIN THIS_VARMAX
. string  *   32   THIS_SIR_REC_NAME
. string  *   32   THIS_SQL_REC_NAME
. integer *    4   THIS_VARLENG
. STRING  *  300   THIS_LINE
. STRING  *  300   FEEDBACK_LINE
. integer *    4   EACH_REC   EACH_VAR  EACH_KEY
. INTEGER *    2   Z_INDS
. INTEGER *    4   EACH_INDEX  EACH_INDEX_VAR
. INTEGER *    4   MAX_INDEX_VAR
. INTEGER *    1   MYSQL_RESERVED   | IS IT A RESERVED WORD IN MYSQL?  BOOLEAN


. Z_INDS = dbinds( 0 )

. STOP_REC = fst ( nglobal( 'STOP_REC'), nrecs (0) )

. compute CREATE_DB_FILE   =  DSN('OUTPUT_DIR') +  '01_' + trim( '<DBNAME>' ) + "_db_create.sql"
. open f_db_create / dsnvar = CREATE_DB_FILE  /write iostat = IO_FEEDBACK lrecl=3000
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CREATE_DB_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
.   EXIT PROGRAM
. ELSE
.   WRITE 'f_db_created: '  CREATE_DB_FILE /
. ENDIF

. write( f_db_create ) 'CREATE DATABASE <DBNAME> ;'
. write( f_db_create ) 'USE <DBNAME> ;' /
. write( f_db_create ) '#################################'
. write( f_db_create ) '## Database Settings-> dbmeta  ##' //
. write( f_db_create ) 'CREATE TABLE db_config (' /
                       ' id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,' /
                       ' db_name VARCHAR( 30 )  NOT NULL,' /
                       ' db_label VARCHAR ( 100 ),' /
                       ' db_type INTEGER, '/
                       ' db_caseid VARCHAR (100)'
. EXECUTE SUBPROCEDURE ADD_LARAVEL_COLUMNS
. write( f_db_create ) ');' |end db_config

| system config
. write( f_db_create ) 'CREATE TABLE system_config (' /
                       ' system_offline INTEGER NOT NULL,' /
                       ' system_version VARCHAR ( 100 )'
. EXECUTE SUBPROCEDURE ADD_LARAVEL_COLUMNS
. write( f_db_create ) ');' |end system_config

. write( f_db_create ) 'CREATE TABLE schema_tables (' /
                       ' table_id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,' /
                       ' table_label VARCHAR ( 200 ),' /
                       ' table_document VARCHAR ( 20000 )' /
. EXECUTE SUBPROCEDURE ADD_LARAVEL_COLUMNS
. write( f_db_create ) ');' |end Table Schema


c??  should user informaiton be "usermeta" instead and be structured Umeta_id (key), user_id, meta_key, meta_value?????
| user information
. write( f_db_create ) 'CREATE TABLE users (' /
                       ' id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,' /
                       ' username VARCHAR ( 64 ),' /
                       ' password VARCHAR ( 64 ),' /
                       ' remember_token VARCHAR ( 100 ),' /
                       ' user_email VARCHAR ( 100 ),' /
                       ' user_first_name VARCHAR ( 100 ),' /
                       ' user_last_name VARCHAR ( 100 ),' /
                       ' user_registered DATE,' /
                       ' user_status INTEGER,' /
                       ' user_first_active DATE,' /
                       ' user_last_active DATE' /
. EXECUTE SUBPROCEDURE ADD_LARAVEL_COLUMNS
. write( f_db_create ) ');' |end user information



. write( f_db_create ) '#################################'
. write( f_db_create ) '## Record Types->Tables      ####' //




. for EACH_REC = 1, STOP_REC
.   compute THIS_SIR_REC_NAME = trim( lower( recname( EACH_REC ) ) )
.   EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_SIR_REC_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.   THIS_SIR_REC_NAME = CLEAN_WORD
.   THIS_SQL_REC_NAME = sglobal('table_prefix') + THIS_SIR_REC_NAME
.   THIS_LINE = 'CREATE TABLE ' + THIS_SQL_REC_NAME + ' ('
.   write ( f_db_create ) THIS_LINE
.   for EACH_VAR = 1, nvarsc( EACH_REC )
.     compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.     EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_VAR_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.     THIS_VAR_NAME = CLEAN_WORD
.     compute THIS_VTYPE = vtype( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )
.     compute THIS_VARLENG = varleng( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )

.     recode THIS_VAR_SQL_TYPE = THIS_VTYPE( 1 = 'VARCHAR' ) ( 2 = 'VARCHAR' ) ( 3 = 'DATE' ) ( 4 = 'TIME' ) ( 5 = 'INTEGER' )
                     ( 6 = 'FLOAT' )( 7 = 'DOUBLE PRECISION' ) ( 8 = 'BIGINT' )
.     THIS_LINE = THIS_VAR_NAME + '  ' + THIS_VAR_SQL_TYPE

.     ifthen( THIS_VAR_SQL_TYPE = 'VARCHAR' )
.       THIS_LINE = THIS_LINE  + '( ' + format( THIS_VARLENG ) + ' )'
.     endif

.     for EACH_KEY = 1, nkeys( EACH_REC ) + dbtype(0)
.       ifthen ( THIS_VAR_NAME EQ lower( trim( keyname( EACH_REC, EACH_KEY ) ) ) )
.         THIS_LINE = THIS_LINE + '  NOT NULL'
.       endif
.     end for

.     if (  EACH_VAR lt nvarsc( EACH_REC ) ) THIS_LINE = THIS_LINE  + ', '

.     write ( f_db_create ) 2T THIS_LINE

.   end for
.   ifthen ( sglobal( 'LARAVEL' ) eq 'yes' )
.     Z_DUMMY = 1 | used as flag to catch columns that already contain laravel column names
.     for EACH_VAR = 1, nvarsc( EACH_REC )
.       compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.       if( THIS_VAR_NAME EQ 'created_at' or 'updated_at') Z_DUMMY = 0
.     end for
.     if ( Z_DUMMY EQ 1 ) EXECUTE SUBPROCEDURE ADD_LARAVEL_COLUMNS  | BUG: CURRENTLY ALL OR NOTHING BASED ON LOOP ABOVE, CONSIDER BREAKING OUT FOR EACH COLUMN
.   endif
.   write( f_db_create ) ' ) ;'

. end for


c variable constraints
. compute CREATE_CONSTRAINT_FILE   =  DSN('OUTPUT_DIR') +  '02_' + trim( '<DBNAME>' ) + "_db_constraints.sql"
. open f_constr / dsnvar = CREATE_CONSTRAINT_FILE  /write iostat = IO_FEEDBACK lrecl=3000
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CREATE_CONSTRAINT_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
.   EXIT PROGRAM
. ELSE
.   WRITE 'Made variable constratins (f_constr) file : '  CREATE_CONSTRAINT_FILE
. ENDIF

. write( f_constr ) '###############################'
. write( f_constr ) '## add primary keys          ##' /
. for EACH_REC = 1, STOP_REC
.   compute THIS_SIR_REC_NAME = trim( lower( recname( EACH_REC ) ) )
.   EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_SIR_REC_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.   THIS_SQL_REC_NAME = sglobal( 'table_prefix' ) + lower( CLEAN_WORD )
.   write( f_constr ) // 'alter table ' THIS_SQL_REC_NAME

.   compute THIS_LINE = 'add constraint ' + THIS_SQL_REC_NAME
.   for EACH_KEY = 1, nkeys( EACH_REC ) + DBTYPE(0)
.     compute THIS_LINE = THIS_LINE + '_' + lower( trim( keyname( EACH_REC, EACH_KEY ) ) )
.   end for
.   compute THIS_LINE = THIS_LINE + '_pk primary key ( '
.   for EACH_KEY = 1, nkeys( EACH_REC ) + DBTYPE(0)
.     CHECK_WORD = lower( trim( keyname( EACH_REC, EACH_KEY ) ) )
.     EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (CHECK_WORD) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.     compute THIS_LINE = THIS_LINE + CLEAN_WORD
.     if (EACH_KEY lt nkeys( EACH_REC ) + DBTYPE(0) ) compute THIS_LINE = THIS_LINE + ', '
.   end for
.   compute THIS_LINE = THIS_LINE + ' );'
.   write( f_constr ) THIS_LINE  /
. end for
. write( f_constr ) '###############################'
. write( f_constr ) '## Create secondary indexes; ##' //

. for EACH_INDEX = 1, Z_INDS
.   compute MAX_INDEX_VAR = dbindv( EACH_INDEX )
.   compute THIS_LINE = 'create index ' + lower( dbindn( EACH_INDEX ) ) + ' on ' + sglobal( 'table_prefix' ) +
                        trimr( lower( recname( dbindr( EACH_INDEX ) ) ) ) + '( '
.   for EACH_INDEX_VAR = 1, MAX_INDEX_VAR
.     CHECK_WORD = lower( pack( dbindt( EACH_INDEX, EACH_INDEX_VAR ) ) )
.     EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (CHECK_WORD) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.     THIS_LINE = THIS_LINE + CLEAN_WORD
.     IF (EACH_INDEX_VAR LT MAX_INDEX_VAR ) THIS_LINE = THIS_LINE + ', '
.   end for
.   THIS_LINE = THIS_LINE + ' );'
.   write( f_constr ) THIS_LINE
. end for
. close ( f_db_create )
. close ( f_constr )


c   EXPORT TO REDCAP SECTION
cif eq '<redcap>', 'yes'
. compute REDCAP_FILE   =  DSN('OUTPUT_DIR') +  '03_' + trim( '<DBNAME>' ) + "_redcap.csv"
. open redcap / dsnvar = REDCAP_FILE /write iostat = IO_FEEDBACK lrecl=3000
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' REDCAP_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
.   EXIT PROGRAM
. ELSE
.   WRITE 'redcap: '  REDCAP_FILE /
. ENDIF
| THE REDCAP HEADERS ARE NECCESSARY FOR IMPORT.  REDCAP AUTOMATICALLY IGNORES THE FIRST LINE OF THE FILE
. THIS_LINE =  'Variable / Field Name,Form Name,Section Header,Field Type,Field Label,' +
               '"Choices, Calculations, OR Slider Labels",Field Note,' +
               'Text Validation Type OR Show Slider Number,Text Validation Min,Text Validation Max,' +
               'Identifier?,Branching Logic'
. write( redcap )
. for EACH_REC = 1, STOP_REC
.   compute THIS_SIR_REC_NAME = trim( lower( recname( EACH_REC ) ) )
.   THIS_SQL_REC_NAME = sglobal( 'TABLE_PREFIX' ) + THIS_SIR_REC_NAME
.   for EACH_VAR = 1, nvarsc( EACH_REC )
.     compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.     compute THIS_VTYPE    = vtype( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )
.     compute THIS_VARLENG  = varleng( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )
.     compute THIS_VARLAB   = varlabsc ( EACH_REC, THIS_VAR_NAME )
.     compute THIS_VARMIN   = FST( FORMAT( NMIN( EACH_REC, THIS_VAR_NAME) ), SMIN ( EACH_REC, THIS_VAR_NAME ), '' )
.     compute THIS_VARMAX   = FST( FORMAT( NMAX( EACH_REC, THIS_VAR_NAME) ), SMAX ( EACH_REC, THIS_VAR_NAME ), '' )

.     ifthen (THIS_VTYPE eq 3)
.       if ( THIS_VARMIN EQ '1' ) THIS_VARMIN = ''
.       if ( THIS_VARMIN EQ '3660000' ) THIS_VARMIN = ''
.       if ( THIS_VARMAX EQ '1' ) THIS_VARMAX = ''
.       if ( THIS_VARMAX EQ '3660000' ) THIS_VARMAX = ''
.       THIS_VARMIN = fst( datec( numbr(THIS_VARMIN), '<date_format>'), '')
.       THIS_VARMAX = fst( datec( numbr(THIS_VARMAX), '<date_format>'), '')
.     elseif (THIS_VTYPE eq 4)
.       THIS_VARMIN = TIMEC( numbr(THIS_VARMIN), '<time_format>')
.       THIS_VARMAX = TIMEC( numbr(THIS_VARMAX), '<time_format>')
.     endif

.     recode  THIS_VAR_REDCAP_TYPE = THIS_VTYPE( 1 = '' ) ( 2 = '' ) ( 3 = 'date' ) ( 4 = 'time' ) ( 5 = 'integer' )
                     ( 6 = 'number' )( 7 = 'number' ) ( 8 = 'number' )
.     ifthen ( nvallab( EACH_REC,  THIS_VAR_NAME) lt 2)
.       THIS_FIELD_TYPE = 'text'
.     elseif ( nvallab( EACH_REC,  THIS_VAR_NAME) eq 2)
.       THIS_FIELD_TYPE = 'radio'
.     else
.       THIS_FIELD_TYPE = 'dropdown'
.     endif

| crazy field min and maxs must be removed if it is a drop down or radio.  ONLY TEXT can have mins and maxs
| for radios and dropdowns there is no field type either!
.     ifthen ( THIS_FIELD_TYPE eq 'radio' or 'dropdown' )
.       THIS_VARMIN = ''
.       THIS_VARMAX = ''
.       THIS_VAR_REDCAP_TYPE = ''
.     endif


|     value labels
.     REDCAP_VALLABS = '"'
.     for EACH_LABEL = 1, nvallab( EACH_REC,  THIS_VAR_NAME)
.       REDCAP_VALLABS = REDCAP_VALLABS + trim( pack( VALLABSV( EACH_REC, THIS_VAR_NAME, EACH_LABEL ) ) )
.       REDCAP_VALLABS = REDCAP_VALLABS + ', '
.       REDCAP_VALLABS = REDCAP_VALLABS + trim( pack( VALLABSN( EACH_REC, THIS_VAR_NAME ,EACH_LABEL ) ) )
.       if (EACH_LABEL lt  nvallab( EACH_REC,  THIS_VAR_NAME) ) REDCAP_VALLABS = REDCAP_VALLABS +  ' | '
.     end for
.     REDCAP_VALLABS = REDCAP_VALLABS + '"'


.     REDCAP_CSV_LINE = THIS_VAR_NAME + ',' +
                    THIS_SQL_REC_NAME + ',' +
                    ',' +
                    THIS_FIELD_TYPE + ',' +
                    THIS_VARLAB + ',' +
                    REDCAP_VALLABS + ',' +
                    ',' +
                    THIS_VAR_REDCAP_TYPE + ',' +
                    THIS_VARMIN + ',' + THIS_VARMAX + ',' +
                    ',' +
                    ',' +
                    ',' +
                    ',' +
                    ','
.     write( redcap ) REDCAP_CSV_LINE
.   end for
. end for
CLOSE (REDCAP)
cif end | end redcap cif


SUBPROCEDURE ADD_LARAVEL_COLUMNS
| SQL requires that the last column does not have a comma after it.  Thus these columns go at the end and assume to be the last columns
.   ifthen ( sglobal( 'laravel' ) eq 'yes' )
.     write( f_db_create ) ' , created_at DATE'
                           ' , updated_at DATE'
.   endif
END SUBPROCEDURE

end program

C -------------------------------------------------------------------------------------------------------------
C -------------------------------------------------------------------------------------------------------------
c create talbes to hold SIR schema information that is not stored in MySQL
program
. STRING  *  300   DB_SCHEMA  DB_SCHEMA_DATA
. STRING  *  300   Z_TABLE_SCHEMA  Z_TABLE_SCHEMA_DATA
. STRING  *  300   Z_VAR_SCHEMA    Z_VAR_SCHEMA_DATA
. STRING  *  300   Z_VALUE_LABELS  Z_VALUE_LABEL_DATA
. string  *  300   THIS_SIR_REC_NAME THIS_SQL_REC_NAME   THIS_VAR_NAME
. integer *    1   THIS_VTYPE
. integer *    4   EACH_REC   EACH_VAR    THIS_VARLENG   EACH_KEY
. INTEGER *    1   MYSQL_RESERVED   | IS IT A RESERVED WORD IN MYSQL?  BOOLEAN
. STRING  *  300   CHECK_WORD  CHECK_FILE
. STRING  *  300   CLEAN_WORD
. STRING  *  300   CSV_VALUE
. STRING  *  3000  CSV_LINE
. INTEGER *    4   IO_FEEDBACK
. STRING  *  200   MYSQL_FILENAME   | JUST INCASE THE FILE NAME FOR DATA IMPORT NEEDS TO BE MANIPULATED BASED ON THE SYSTEM
. STRING  *    6   LINE_TERMINATOR
. integer *    4   STOP_REC        | What record number should this stop at.  Used for sampling and testing.

. STOP_REC = fst ( nglobal( 'STOP_REC'), nrecs (0) )
. LINE_TERMINATOR = '<LINE_TERMINATOR>'

compute DB_SCHEMA      =  DSN('OUTPUT_DIR') +  '03a_' + trim( '<DBNAME>' ) + "_db_schema.sql"
compute DB_SCHEMA_DATA =  DSN('OUTPUT_DIR') +  '03b_' + trim( '<DBNAME>' ) + "_db_schema_data.csv"
compute Z_TABLE_SCHEMA      =  DSN('OUTPUT_DIR') +  '04a_' + trim( '<DBNAME>' ) + "_table_schema.sql"
compute Z_TABLE_SCHEMA_DATA =  DSN('OUTPUT_DIR') +  '04b_' + trim( '<DBNAME>' ) + "_table_schema_data.csv"
compute Z_VAR_SCHEMA        =  DSN('OUTPUT_DIR') +  '04c_' + trim( '<DBNAME>' ) + "_var_schema.sql"
compute Z_VAR_SCHEMA_DATA   =  DSN('OUTPUT_DIR') +  '04d_' + trim( '<DBNAME>' ) + "_var_schema_data.csv"
compute Z_VALUE_LABELS      =  DSN('OUTPUT_DIR') +  '05a_' + trim( '<DBNAME>' ) + "_value_label_schema.sql"
compute Z_VALUE_LABEL_DATA  =  DSN('OUTPUT_DIR') +  '05b_' + trim( '<DBNAME>' ) + "_value_label_data.csv"


DO REPEAT EACH_FILENAME = F_DB_SCHEMA      F_DB_SCHEMA_DATA
                          F_TABLE_SCHEMA   F_TABLE_SCHEMA_DATA
                          F_VAR_SCHEMA     F_VAR_SCHEMA_DATA
                          F_VALUE_LABELS   F_VALUE_LABEL_DATA  /
          EACH_PATH =     DB_SCHEMA        DB_SCHEMA_DATA
                          Z_TABLE_SCHEMA   Z_TABLE_SCHEMA_DATA
                          Z_VAR_SCHEMA     Z_VAR_SCHEMA_DATA
                          Z_VALUE_LABELS   Z_VALUE_LABEL_DATA

. open EACH_FILENAME / dsnvar = EACH_PATH  /write iostat = IO_FEEDBACK lrecl=3000
. CHECK_FILE = EACH_PATH
. execute subprocedure CHECK_IO
end repeat

C ------------------
C DATABASE META
MYSQL_FILENAME = DB_SCHEMA_DATA
EXECUTE SUBPROCEDURE ESCAPE_SLASHES
write ( F_DB_SCHEMA ) 'LOAD DATA LOCAL ' /
                          ["INFILE '" + MYSQL_FILENAME  + "'" ] /
                          'INTO TABLE DB_CONFIG' /
                          "COLUMNS TERMINATED BY ','" /
			  "OPTIONALLY ENCLOSED BY '""'"/
			  "ESCAPED BY '""'"/
			  "LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                          "IGNORE 1 LINES;"/

write( F_DB_SCHEMA_DATA ) '"id"<DELIMINATOR>'
                          '"db_name"<DELIMINATOR>'
                          '"db_label"<DELIMINATOR>'
                          '"db_type"<DELIMINATOR>'
                          '"db_caseid"<DELIMINATOR>'
CSV_LINE = '0<DELIMINATOR>"' + dbname(0) + '"<DELIMINATOR>"' +
           fst( recdoc(0,0), dbname(0) )  +  '"<DELIMINATOR>"' +
           format(dbtype(0)) + '"<DELIMINATOR>"' +
           fst(varname(0,1), '') + '"'
. ifthen ( sglobal( 'LARAVEL' ) eq 'yes' )
.  CSV_LINE = CSV_LINE + ',' + datec(today(0),'yyyymmdd') + ',' + datec(today(0),'yyyymmdd')
. endif
. write( F_DB_SCHEMA_DATA ) CSV_LINE


C ------------------
c variable details
write( F_VAR_SCHEMA ) 'CREATE TABLE SCHEMA_VARIABLE (' /
                     4T 'id int NOT NULL AUTO_INCREMENT PRIMARY KEY,' /
                     4T 'table_name varchar(255),' /
                     4T 'variable_name varchar(255),' /
                     4T 'variable_label varchar(255),' /
                     4T 'variable_document varchar(255),' /
                     4T 'variable_read_security varchar(255),' /
                     4T 'variable_write_security varchar(255),' /
                     4T 'variable_stattype varchar(255),' /
                     4T 'variable_type varchar(255),' /
                     4T 'variable_length varchar(255),' /
                     4T 'variable_scale varchar(255),' /
                     4T 'variable_missing1 varchar(255),' /
                     4T 'variable_missing2 varchar(255),' /
                     4T 'variable_missing3 varchar(255),' /
                     4T 'variable_range_min varchar(255),' /
                     4T 'variable_range_max varchar(255),' /
                     4T 'variable_valid_value varchar(255),' /
                     4T 'variable_required INTEGER' /
                     ');' /

MYSQL_FILENAME = Z_VAR_SCHEMA_DATA
EXECUTE SUBPROCEDURE ESCAPE_SLASHES
write ( f_VAR_SCHEMA ) 'LOAD DATA LOCAL ' /
                          ["INFILE '" + MYSQL_FILENAME  + "'" ] /
                          'INTO TABLE SCHEMA_VARIABLE' /
                          "COLUMNS TERMINATED BY ','" /
			  "OPTIONALLY ENCLOSED BY '""'"/
			  "ESCAPED BY '""'"/
			  "LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                          "IGNORE 1 LINES;"/

C ------------------
C TABLE SCHEMA
write( F_TABLE_SCHEMA ) 'CREATE TABLE schema_table('/
                       4T ' table_id INTEGER NOT NULL AUTO_INCREMENT PRIMARY KEY,' /
                       4T ' table_name VARCHAR ( 200 ),' /
                       4T ' table_label VARCHAR ( 200 ),' /
                       4T ' table_document VARCHAR ( 20000 )' /
                       ');' /
MYSQL_FILENAME = Z_TABLE_SCHEMA_DATA
EXECUTE SUBPROCEDURE ESCAPE_SLASHES
write ( F_TABLE_SCHEMA ) 'LOAD DATA LOCAL ' /
                          ["INFILE '" + MYSQL_FILENAME + "'" ] /
                          'INTO TABLE SCHEMA_TABLE' /
                          "COLUMNS TERMINATED BY ','" /
                          "OPTIONALLY ENCLOSED BY '""'"/
                          "ESCAPED BY '""'"/
			  "LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                          "IGNORE 0 LINES;"/

C ------------------
C VALUE LABELS TABLE
write( f_value_labels ) 'CREATE TABLE SCHEMA_VALUE_LABELS ('/
                     4T 'id int NOT NULL AUTO_INCREMENT PRIMARY KEY ,'/
                     4T 'table_name varchar(255),'/
                     4T 'variable_name varchar(255),'/
                     4T 'value_value varchar(255),'/
                     4T 'value_label varchar(255)'/
                     ');'
MYSQL_FILENAME = Z_value_label_data
EXECUTE SUBPROCEDURE ESCAPE_SLASHES
write ( f_value_labels ) 'LOAD DATA LOCAL ' /
                          ["INFILE '" + MYSQL_FILENAME + "'" ] /
                          'INTO TABLE SCHEMA_VALUE_LABELS' /
                          "COLUMNS TERMINATED BY ','" /
                          "OPTIONALLY ENCLOSED BY '""'"/
                          "ESCAPED BY '""'"/
			  "LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                          "IGNORE 0 LINES;"/



WRITE ( F_VAR_SCHEMA_DATA ) '"id"<DELIMINATOR>'
                            '"table_name"<DELIMINATOR>'
                            '"variable_name"<DELIMINATOR>'
                            '"variable_label"<DELIMINATOR>'
                            '"variable_document"<DELIMINATOR>'
                            '"variable_read_security"<DELIMINATOR>'
                            '"variable_write_security"<DELIMINATOR>'
                            '"variable_stattype"<DELIMINATOR>'
                            '"variable_type"<DELIMINATOR>'
                            '"variable_length"<DELIMINATOR>'
                            '"variable_scale"<DELIMINATOR>'
                            '"variable_missing1"<DELIMINATOR>'
                            '"variable_missing2"<DELIMINATOR>'
                            '"variable_missing3"<DELIMINATOR>'
                            '"variable_range_min"<DELIMINATOR>'
                            '"variable_range_max"<DELIMINATOR>'
                            '"variable_valid_value"<DELIMINATOR>'
                            '"variable_required"<DELIMINATOR>'


write 'Files created ' / 'F_DB_SCHEMA: '         [ dsn( 'f_DB_SCHEMA' ) ] /
                         'f_DB_SCHEMA_data: '    [ dsn( 'f_DB_SCHEMA_data' ) ] /
                         'F_TABLE_SCHEMA: '      [ dsn( 'f_TABLE_SCHEMA' ) ] /
                         'f_TABLE_SCHEMA_data: ' [ dsn( 'f_TABLE_SCHEMA_data' ) ] /
                         'f_VAR_SCHEMA: '        [ dsn( 'f_VAR_SCHEMA' ) ] /
                         'f_VAR_SCHEMA_data: '   [ dsn( 'f_VAR_SCHEMA_data' ) ] /
                         'f_value_labels: '      [ dsn( 'f_value_labels' ) ] /
                         'f_value_label_data: '  [ dsn( 'f_value_label_data' ) ] /

for EACH_REC = 1, STOP_REC
. compute THIS_SIR_REC_NAME = trim( lower( recname( EACH_REC ) ) )
. if( exists( THIS_SIR_REC_NAME ) eq 0 ) next for


C ---------------
C TABLE SCHEMA

C FIRST COLUMN IS AUTO-INT
. CSV_LINE = "0<DELIMINATOR>"

c variable schema
. EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_SIR_REC_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
. THIS_SQL_REC_NAME = sglobal( 'table_prefix' ) + CLEAN_WORD
. CSV_LINE = CSV_LINE + '"' + THIS_SQL_REC_NAME + '",'  |table name

. CSV_VALUE = trim( recname( EACH_REC ) )
. EXECUTE SUBPROCEDURE MAKE_FILE_LINE;

. CSV_VALUE = trimlr( recdoc( EACH_REC, 0) )
. EXECUTE SUBPROCEDURE MAKE_FILE_LINE;

. IF ( SUBSTR( CSV_LINE, LEN( CSV_LINE ), 1 ) EQ ',' ) CSV_LINE = SUBSTR( CSV_LINE, 1, LEN( CSV_LINE )  -1)
. WRITE ( f_TABLE_SCHEMA_data ) CSV_LINE

C ---------------
C VARIABLE SCHEMA
. for EACH_VAR = 1, nvarsc( EACH_REC )
.   compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.   compute THIS_VTYPE    = vtype( EACH_REC, THIS_VAR_NAME )
.   compute THIS_VARLENG  = varleng( EACH_REC, THIS_VAR_NAME )

.   recode THIS_VAR_SQL_TYPE = THIS_VTYPE( 1 = 'VARCHAR' )( 2 = 'VARCHAR' )( 3 = 'DATE' )( 4 = 'TIME' )( 5 = 'INTEGER' )
    ( 6 = 'FLOAT' )( 7 = 'DOUBLE PRECISION' )( 8 = 'BIGINT' )

C   FIRST COLUMN IS AUTO-INT
.   CSV_LINE = "0<DELIMINATOR>"

c   variable schema
.   EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_SIR_REC_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.   THIS_SQL_REC_NAME = sglobal( 'table_prefix' ) + CLEAN_WORD
.   CSV_LINE = CSV_LINE + '"' + THIS_SQL_REC_NAME + '",'  |table name

.   EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_VAR_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.   CSV_LINE = CSV_LINE + '"' + CLEAN_WORD + '",'  | variable name

C   - VARIABLE LABEL
.   CSV_VALUE = VARLABSC ( EACH_REC, THIS_VAR_NAME )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE;

C   - VARIABLE DOCUMENT
.   CSV_VALUE = ""
.   FOR EACH_LINE = 1, NVARDOC ( EACH_REC, THIS_VAR_NAME )
.     CSV_VALUE = CSV_VALUE + VARDOCSN ( EACH_REC, THIS_VAR_NAME, EACH_LINE )
.   END FOR
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_READ_SECURITY
.   CSV_VALUE = FORMAT( RVARSEC( EACH_REC, THIS_VAR_NAME ) )
.   if (CSV_VALUE = '0') CSV_VALUE = ''
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_WRITE_SECURITY
.   CSV_VALUE = FORMAT( WVARSEC( EACH_REC, THIS_VAR_NAME ) )
.   if (CSV_VALUE = '0') CSV_VALUE = ''
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_STATTYPE 0=None, 1=Observation, 2=Control
.   CSV_VALUE = FORMAT( STATTYPE ( EACH_REC, THIS_VAR_NAME ) )
.   if (CSV_VALUE = '0') CSV_VALUE = ''
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_TYPE
.   CSV_VALUE = FORMAT( VTYPE    ( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   -  VARIABLE_LENGTH  FOR STRINGS
.   IFTHEN( VTYPE ( EACH_REC, THIS_VAR_NAME ) = 1 OR 2 )
.     CSV_VALUE = FORMAT( VARLENG  ( EACH_REC, THIS_VAR_NAME ) )
.   ELSE
.     CSV_VALUE = ''
.   ENDIF
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_SCALE
.   CSV_VALUE = FORMAT( VSCALE   ( EACH_REC, THIS_VAR_NAME ) )
.   if (CSV_VALUE = '0') CSV_VALUE = ''
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_MISSING1
.   CSV_VALUE = MISS     ( EACH_REC, THIS_VAR_NAME, 1 )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_MISSING2
.   CSV_VALUE = MISS     ( EACH_REC, THIS_VAR_NAME, 2 )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_MISSING3
.   CSV_VALUE = MISS     ( EACH_REC, THIS_VAR_NAME, 3 )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_RANGE_MIN
.   ifthen ( vtype( EACH_REC, THIS_VAR_NAME ) eq 3 ) | Date
.     CSV_VALUE = datec( nmin( EACH_REC, THIS_VAR_NAME) , 'mm/dd/yyyy' )
.   elseif ( vtype( EACH_REC, THIS_VAR_NAME ) eq 4 ) | time
.     CSV_VALUE = timec( nmin( EACH_REC, THIS_VAR_NAME) , 'hh:mm:ss' )
.   else
.     CSV_VALUE = fst( format( nmin( EACH_REC, THIS_VAR_NAME) ), smin ( EACH_REC, THIS_VAR_NAME ) )
.   endif
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_RANGE_Max
.   ifthen( vtype( EACH_REC, THIS_VAR_NAME ) eq 3 ) | Date
.     CSV_VALUE = datec( nmax( EACH_REC, THIS_VAR_NAME) , 'mm/dd/yyyy' )
.   elseif( vtype( EACH_REC, THIS_VAR_NAME ) eq 4 ) | time
.     CSV_VALUE = timec( nmax( EACH_REC, THIS_VAR_NAME) , 'hh:mm:ss' )
.   else
.     CSV_VALUE = fst( format( nmax( EACH_REC, THIS_VAR_NAME) ), smin( EACH_REC, THIS_VAR_NAME ) )
.   endif
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

c   Valid Values
C   COME BACK ON WORK ON THIS.  SHOULD IT BE A COMMA SEPARATED LIST?  CHECK OUT HOW WORDPRESS AND JOOMLA HANDLE THINGS LIKE THIS
C.  WRITE ( f_value_label_data/noeol ) VARIABLE_VALID_VALUE
.   CSV_VALUE = ''
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

c   Required  Note: SIR Does NOT have "required" in the variable schema
.   CSV_VALUE = ''
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

.   EXECUTE SUBPROCEDURE TRIM_LAST_COMMA
.   WRITE ( f_VAR_SCHEMA_data ) CSV_LINE

C ------------------
C -  VALUE LABELS  -
.   CSV_LINE = ''
.   for EACH_LABEL = 1, nvallab( EACH_REC,  THIS_VAR_NAME)
.     CSV_LINE = '0<DELIMINATOR>'
.     CSV_VALUE = THIS_SQL_REC_NAME; EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     CSV_VALUE = THIS_VAR_NAME; EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     CSV_VALUE = VALLABSV ( EACH_REC, THIS_VAR_NAME, EACH_LABEL ); EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     CSV_VALUE = VALLABSN( EACH_REC, THIS_VAR_NAME ,EACH_LABEL ) ; EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     EXECUTE SUBPROCEDURE TRIM_LAST_COMMA
.     WRITE ( f_value_label_data ) CSV_LINE
.   end for


. END FOR
END FOR



C CREATE VARIABLE INFORMATION FOR BUILT IN TABLE USER_INFORMATION
C USER ID
WRITE ( F_VAR_SCHEMA_DATA ) '0<DELIMINATOR>"user_information"<DELIMINATOR>"user_id"<DELIMINATOR>'
                            '"User ID"<DELIMINATOR>Auto Incrementing User ID.  Unique<DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR>"INTEGER"<DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR><NULL_VALUE>'
C USER LOGIN NAME
WRITE ( F_VAR_SCHEMA_DATA ) '0<DELIMINATOR>"user_information"<DELIMINATOR>"user_login"<DELIMINATOR>'
                            '"User Login"<DELIMINATOR>Unique<DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR>"VARCHAR"<DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR><NULL_VALUE>'
C USER LOGIN Password
WRITE ( F_VAR_SCHEMA_DATA ) '0<DELIMINATOR>"user_information"<DELIMINATOR>"user_password"<DELIMINATOR>'
                            '"User Password"<DELIMINATOR>Encrypted<DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR>"VARCHAR"<DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR>'
                            '<NULL_VALUE><DELIMINATOR><NULL_VALUE><DELIMINATOR><NULL_VALUE>'






close ( DB_SCHEMA )
close ( DB_SCHEMA_data )
close ( f_TABLE_SCHEMA )
close ( f_TABLE_SCHEMA_data )
close ( f_VAR_SCHEMA )
close ( f_VAR_SCHEMA_data )
close ( f_value_labels )
close ( f_value_label_data)


SUBPROCEDURE CHECK_IO
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CHECK_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
. ENDIF
END SUBPROCEDURE

subprocedure MAKE_FILE_LINE
C CREATE A LINE THAT CAN BE READ IN BY MYSQL
. IF ( EXISTS( CSV_LINE ) EQ 0 ) CSV_LINE = ""
. CSV_VALUE =  replace( CSV_VALUE, '"', '""', 99, 2, 0 ) | 2 double qoutes when imported turn into 1 double qoute
. CSV_VALUE =  replace( CSV_VALUE, "’", "'", 99, 2, 0 )  | Back qoutes must be changed.  Back qoute is MYSQL KEYWORD

. IFTHEN ( EXISTS( CSV_VALUE ) EQ 0)
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( pack( trimlr( CSV_VALUE ) ) EQ '' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( CSV_VALUE EQ 'NULL' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSE
.   CSV_VALUE =  '"' + TRIMR( CSV_VALUE) + '"'       | ADD QOUTES AND GET RID OF TRAILING SPACES
. ENDIF

. CSV_LINE = CSV_LINE + CSV_VALUE + '<DELIMINATOR>'
end subprocedure

SUBPROCEDURE TRIM_LAST_COMMA
. CSV_LINE = TRIMR( CSV_LINE )
c bug in code.  I don't remember why this is commented out!
C . IF ( SUBSTR( CSV_LINE, LEN( CSV_LINE ), 1 ) EQ ',' ) CSV_LINE = SUBSTR( CSV_LINE, 1, LEN( CSV_LINE )  -1)
END SUBPROCEDURE

SUBPROCEDURE ESCAPE_SLASHES
c for windows the "\" in the file path must be escaped as it is a SQL reserved keyword
. IFNOT ( 0<WINDOWS_MACHINE> EQ 1 ) EXIT SUBPROCEDURE
. MYSQL_FILENAME = replace( MYSQL_FILENAME , '\', '\\', 99, 2, 0 )
END SUBPROCEDURE

end program


C -------------------------------------------------------------------------------------------------------------
C ------------------------------          EXPORT DATA          ------------------------------------------------


program crwarn
string  *   78   THIS_SIR_REC_NAME THIS_SQL_REC_NAME
STRING  *   78   THIS_VAR_NAME
STRING  *  300   Z_SQLFN  Z_DATFN
STRING  *  300   Z_LOADIT
STRING  *  300   Z_DATA
string  *  3000  THIS_LINE
string  *  300   BASE_DIR
INTEGER *    1   PASSFAIL
real    *    8   Z_DUMMY
integer *    1   THIS_VTYPE
integer *    4   EACH_REC   EACH_VAR    THIS_VARLENG   EACH_KEY
STRING  *   32   THIS_VAR_SQL_TYPE
STRING  *  100   Z_VTERM
INTEGER *    4   IO_FEEDBACK
INTEGER *    1   MYSQL_RESERVED   | IS IT A RESERVED WORD IN MYSQL?  BOOLEAN
STRING  *  200   MYSQL_FILENAME   | JUST INCASE THE FILE NAME FOR DATA IMPORT NEEDS TO BE MANIPULATED BASED ON THE SYSTEM
STRING  *  300   CHECK_WORD  CHECK_FILE
STRING  *  300   CLEAN_WORD
STRING  *  300   CSV_VALUE
STRING  *  3000  CSV_LINE
STRING  *    6   LINE_TERMINATOR
integer *    4   STOP_REC        | What record number should this stop at.  Used for sampling and testing.

LINE_TERMINATOR = '<LINE_TERMINATOR>'

STOP_REC = fst ( nglobal( 'STOP_REC'), nrecs (0) )

BASE_DIR = dsn( 'output_dir' )

compute Z_DATA    =  BASE_DIR +  trim( '<DBNAME>' ) + "_data.pql"
compute Z_LOADIT  =  BASE_DIR +  '07_' + trim( '<DBNAME>' ) + "_loadit"
compute Z_DUMMY   =  globals( "DATAPROG",  Z_DATA )
compute Z_DUMMY   =  globals( "LOADIT",  Z_LOADIT )
compute Z_DUMMY   =  globalN( "G_CONTINUE",  1) | RETRIEVAL EXECUTED.
C OPEN THE NECESSARY FILES

DO REPEAT EACH_FILENAME = F_LOADIT  F_DATA /
          EACH_PATH =     Z_LOADIT  Z_DATA

. open EACH_FILENAME / dsnvar = EACH_PATH  /write iostat = IO_FEEDBACK lrecl=3000
. CHECK_FILE = EACH_PATH
. execute subprocedure CHECK_IO
end repeat



write 'Files created ' / 'f_loadit: '           [ dsn( 'f_loadit' ) ] /
                         'f_data:   '           [ dsn( 'f_data' ) ] /
      '-------------------------' //


. write( f_loadit ) "#!/bin/sh"
. ifthen( '<NEW>' = 'no' )
.   write( f_loadit )["mysql --local-infile = 1 --database = <DBNAME> --password = <password> --user = <username> --execute = 'drop database <DBNAME>'"]
. endif
. write( f_loadit )["mysql --local-infile = 1 --password = <password> --user = <username> --execute = 'source " + dsn( 'f_db_create' ) + "'"]
. write( f_loadit )["mysql --local-infile = 1 --database = <DBNAME> --password = <password> --user = <username> --execute = 'source " + DSN( 'f_constr' ) + "'"]

for EACH_REC = 1, STOP_REC
. THIS_SIR_REC_NAME = trim( lower( recname( EACH_REC ) ) )
. if( exists( THIS_SIR_REC_NAME ) eq 0 ) next for
. THIS_SQL_REC_NAME = sglobal( 'TABLE_PREFIX' ) + THIS_SIR_REC_NAME
. compute Z_SQLFN = BASE_DIR +  THIS_SQL_REC_NAME + '.sql'
. compute Z_DATFN = BASE_DIR +  THIS_SQL_REC_NAME + '.<FILE_ENDING>'
. write( f_data ) 'remark "Creating Rec# ' EACH_REC ': ' THIS_SIR_REC_NAME '"'
. write( f_data ) 'remark "' Z_SQLFN  '"'
. write( f_data ) 'remark "' Z_DATFN  '"'
. write( f_data ) // 'RETRIEVAL SEED = <CASE_SEEDER> |' EACH_REC ': ' THIS_SIR_REC_NAME
. write( f_data ) 'string * 4094  DATA_LINE'
. write( f_data ) 'string * 4094  DATA_VALUE'

. write( f_loadit )["mysql --local-infile = 1 --database = <DBNAME> --password = <password> --user = <username> --execute = 'source " + Z_SQLFN + "'"]
. open f_zsqlfn / dsnvar = Z_SQLFN / write

. MYSQL_FILENAME = Z_DATFN
. EXECUTE SUBPROCEDURE ESCAPE_SLASHES
. write( f_zsqlfn ) "LOAD DATA LOCAL "
. write( f_zsqlfn ) ["INFILE '" + MYSQL_FILENAME + "'"] /
                    " INTO TABLE " THIS_SQL_REC_NAME /
                    " COLUMNS TERMINATED BY '<SQL_DELIMINATOR>'" /
                    " OPTIONALLY ENCLOSED BY '""'"/
                    " ESCAPED BY '""'"/
                    " LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                    " IGNORE 1 LINES;"/


. write( f_data ) 'compute DELIM = <PQL_DELIMINATOR>'
. write( f_data ) ['open f_datafile / dsn = "' + Z_DATFN + '"/write/lrecl = 4000']

c include column headers
. write( f_data/noeol) 'write( f_datafile) '
. THIS_LINE = '"'

c longitudinal records in redcap have a funny field called "redcap_event_name".  It is their version of a key field
c KEY VALUES MUST BE CONVERTED TO SHIT LIKE THIS "1_arm_1" AND "2_arm_1" AND AND "1_arm_2" instead of their original values for data import!
cif eq '<redcap>', 'yes'
. ifthen ( nkeys ( EACH_REC) gt 0 ) | has a key field
.   for EACH_KEY = 1, nkeys( EACH_REC )
.     compute THIS_VAR_NAME = lower( trim( keyname( EACH_REC, EACH_KEY ) ) )
.     THIS_LINE = THIS_LINE + THIS_VAR_NAME
.     IF ( EACH_KEY LT nkeys( EACH_REC ) ) THIS_LINE = THIS_LINE + '_'
.   end for
.   THIS_LINE = THIS_LINE + 'redcap_event_name<DELIMINATOR>'
.   write 'redcap_event_name for ' THIS_SIR_REC_NAME ' is a combination of variables: '
. endif
cif end
. for EACH_VAR = 1, nvarsc( EACH_REC )
.   compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.   THIS_LINE = THIS_LINE + THIS_VAR_NAME
.   if ( EACH_VAR lt nvarsc( EACH_REC ) ) THIS_LINE = THIS_LINE + '<DELIMINATOR>'
.   ifthen ( amod( EACH_VAR, 10 ) GE 0 ) | keep it to 10 variables on a line
.     THIS_LINE = THIS_LINE + '"'
.     write( f_data) 5T THIS_LINE
.     THIS_LINE = '     "'  | add indented space to make the new line readable
.   endif
. end for

. write( f_data ) 'process cases <CASE_RESTRICTION> '
. write( f_data ) 'process rec ' THIS_SIR_REC_NAME
. write( f_data ) 'get vars all'
. write( f_data ) 'DATA_LINE = ""'

. for EACH_VAR = 1, nvarsc( EACH_REC )
.   ifthen(  EACH_VAR LT nvarsc( EACH_REC ) )
.     compute Z_VTERM = 'DELIM'
.   else
.     compute Z_VTERM = ""
.   endif
.   compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.   compute THIS_VTYPE    = vtype( EACH_REC, THIS_VAR_NAME )
.   compute THIS_VARLENG  = varleng( EACH_REC, THIS_VAR_NAME )

.   recode THIS_VAR_SQL_TYPE = THIS_VTYPE( 1 = 'VARCHAR' )( 2 = 'VARCHAR' )( 3 = 'DATE' )( 4 = 'TIME' )( 5 = 'INTEGER' )
    ( 6 = 'FLOAT' )( 7 = 'DOUBLE PRECISION' )( 8 = 'BIGINT' )
.   EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_VAR_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.   write( f_datafile/noeol ) CLEAN_WORD

.   THIS_LINE = ''
.   ifthen( THIS_VAR_SQL_TYPE  = 'VARCHAR' )
.     THIS_LINE = 'DATA_VALUE = fst( ' + THIS_VAR_NAME + ', missing( ' + THIS_VAR_NAME + ' ) )'
.     write( f_data ) THIS_LINE
.     THIS_LINE = 'DATA_VALUE = ''"'' + DATA_VALUE + ''"'''
.   elseif( THIS_VAR_SQL_TYPE = 'INTEGER' or 'FLOAT' or 'DOUBLE PRECISION' or 'BIGINT' )
.     THIS_LINE = 'DATA_VALUE = format( fst( ' + THIS_VAR_NAME + ', missing( ' + THIS_VAR_NAME + ' ) ) )'
.   else
.     ifthen( THIS_VTYPE = 3 )
.       THIS_LINE = 'DATA_VALUE = datec( ' + THIS_VAR_NAME + ', "<date_format>" )'
.     else
.       THIS_LINE = 'DATA_VALUE = timec( ' + THIS_VAR_NAME + ', "<time_format>" )'
.     endif
.   endif
.   write( f_data ) THIS_LINE
.   write( f_data ) 'EXECUTE SUBPROCEDURE ADD_VALUE_TO_LINE' /

|   close the create table sql statement
.   ifthen(  EACH_VAR lt nvarsc( EACH_REC ) )
.     | DO NOTHING
.   else
.     write( f_data ) 'write( f_datafile ) DATA_LINE'
.     write( f_data ) 'end process rec'
.     write( f_data ) 'end process cases'
.     write( f_data ) 'close( f_datafile )'

.     write( f_data ) //
.     write( f_data ) 'SUBPROCEDURE ADD_VALUE_TO_LINE'
.     write( f_data ) '. IFTHEN ( ( DATA_VALUE NE "" ) OR ( EXISTS( DATA_VALUE ) EQ 1 ) )'
.     write( f_data ) '.   DATA_LINE = DATA_LINE + DATA_VALUE'
.     write( f_data ) '. ELSE'
.     write( f_data ) '.   DATA_LINE = DATA_LINE + "<NULL_VALUE>"'
.     write( f_data ) '. ENDIF'
.     write( f_data ) '. DATA_LINE = DATA_LINE + DELIM'
.     write( f_data ) 'end subprocedure'

.     write( f_data ) 'end retrieval'
.     close( f_zsqlfn )
.   end if
. end for
end for

close ( f_data )
close ( loadit )

SUBPROCEDURE CHECK_IO
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CHECK_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
. ENDIF
END SUBPROCEDURE

subprocedure MAKE_FILE_LINE
C CREATE A LINE THAT CAN BE READ IN BY MYSQL
. IF ( EXISTS( CSV_LINE ) EQ 0 ) CSV_LINE = ""
. CSV_VALUE =  replace( CSV_VALUE, '"', '""', 99, 2, 0 ) | 2 double qoutes when imported turn into 1 double qoute
. CSV_VALUE =  replace( CSV_VALUE, "’", "'", 99, 2, 0 )  | There is an issue with the back qoutes and importing into MySQL`

. IFTHEN ( EXISTS( CSV_VALUE ) EQ 0)
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( pack( trimlr( CSV_VALUE ) ) EQ '' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( CSV_VALUE EQ 'NULL' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSE
.   CSV_VALUE =  '"' + TRIMR( CSV_VALUE) + '"'       | ADD QOUTES AND GET RID OF TRAILING SPACES
. ENDIF

. CSV_LINE = CSV_LINE + CSV_VALUE + '<DELIMINATOR>'
end subprocedure

SUBPROCEDURE TRIM_LAST_COMMA
. CSV_LINE = TRIMR( CSV_LINE )
C . IF ( SUBSTR( CSV_LINE, LEN( CSV_LINE ), 1 ) EQ ',' ) CSV_LINE = SUBSTR( CSV_LINE, 1, LEN( CSV_LINE )  -1)
END SUBPROCEDURE

SUBPROCEDURE ESCAPE_SLASHES
c for windows the "\" in the file path must be escaped as it is a SQL reserved keyword
. IFNOT ( 0<WINDOWS_MACHINE> EQ 1 ) EXIT SUBPROCEDURE
. MYSQL_FILENAME = replace( MYSQL_FILENAME , '\', '\\', 99, 2, 0 )
END SUBPROCEDURE

end program

REMARK 'INCLUDING <DATAPROG>'

include file "<DATAPROG>"

REMARK 'CONTINUING TO CREATE DATABASE AND LOAD DATA: <LOADIT>'

cif eq '<G_CONTINUE>', '1'
program
pql escape "chmod 755 <LOADIT>"
pql escape "<LOADIT>"
end program
CIF END


c create laravel files
program
. string  *  250   LARAVEL_DIR
. string  *  250   LARAVEL_APP_DIR
. string  *  250   LARAVEL_MODELS_DIR
. string  *  250   LARAVEL_CONTROLLERS_DIR
. string  *  250   LARAVEL_VIEWS_DIR
. string  *  250   FILE_PATH FILE_NAME
. STRING  *    6   FILE_EXT
. STRING  *  250   EACH_PATH
. INTEGER *    2   EACH_CHAR
. integer *    4   PASSFAIL
. string  *  300   DBMS_LINE
. INTEGER *    4   STOP_REC
. STRING  *  300   CHECK_WORD
. STRING  *  300   CLEAN_WORD
. INTEGER *    1   MYSQL_RESERVED   | IS IT A RESERVED WORD IN MYSQL?  BOOLEAN
. integer *    4   IO_FEEDBACK

. ifNOT ( sglobal( 'LARAVEL' ) eq 'yes' ) exit program

. LARAVEL_APP_DIR = dsn( 'prefix' )  +  'to_mysql\Laravel\app\'
. LARAVEL_MODELS_DIR = LARAVEL_APP_DIR + 'models\'
. LARAVEL_CONOTROLLERS_DIR = LARAVEL_APP_DIR + 'controllers\'
. LARAVEL_VIEWS_DIR = LARAVEL_APP_DIR + 'views\'

. STOP_REC = fst ( nglobal( 'STOP_REC'), nrecs (0) )
. for EACH_REC = 1, STOP_REC
.   if( exists( RECNAME( EACH_REC ) ) eq 0 ) next for
.   compute THIS_SIR_REC_NAME = trim( lower( recname( EACH_REC ) ) )
.   EXECUTE SUBROUTINE TOOLS.CHECK_RESERVED_WORDS (THIS_SIR_REC_NAME) RETURNING (CLEAN_WORD MYSQL_RESERVED)
.   THIS_SIR_REC_NAME = CLEAN_WORD
.   THIS_SQL_REC_NAME = sglobal('table_prefix') + THIS_SIR_REC_NAME
.   EACH_PATH  = LARAVEL_MODELS_DIR + capital(THIS_SQL_REC_NAME ) + '.php'
.   open EACH_FILENAME / dsnvar = EACH_PATH  /write iostat = IO_FEEDBACK lrecl=3000
.     if ( IO_FEEDBACK <> 0 ) write 'Failed to open ' EACH_PATH LARAVEL_MODELS_DIR
.     write (EACH_FILENAME) '<?php'
.     write (EACH_FILENAME) ['class ' + capital(THIS_SQL_REC_NAME) + ' extends Eloquent {']
.     write (EACH_FILENAME) ["protected $table = '" + THIS_SQL_REC_NAME + "';"]
.     ifthen ( dbtype(0) eq 1 )
.       write (EACH_FILENAME) ["protected $primaryKey = '" + lower( varname(0,1 ) )+ "';"]
.     endif
.     write (EACH_FILENAME) '}'
.     write (EACH_FILENAME) '?>'
.   close (EACH_FILENAME)
. end for

. FILE_PATH = LARAVEL_MODELS_DIR + 'Db_config' + '.php'
. open db_config / dsnvar = FILE_PATH /write iostat = IO_FEEDBACK lrecl=3000
.   write (db_config) '<?php' /
                    'class Db_config extends Eloquent {' /
                    5t "protected $table = 'db_config';" /
                    5t "public $fillable= array('db_label','db_type','db_caseid');"/
                    '}'/
                    '?>'
. close db_config


. FILE_PATH = LARAVEL_MODELS_DIR + 'Schema_variable' + '.php'
. open sch_var / dsnvar = FILE_PATH /write iostat = IO_FEEDBACK lrecl=3000
.   write (sch_var) '<?php' /
                    'class Schema_variable  extends Eloquent {' /
                    5t "protected $table = 'Schema_variable';" /
                    5t "protected $guarded = array('_token');" /
                    5t "protected $primaryKey = 'id';"/
                    5t "public $timestamps = false;"/
                    '}'/
                    '?>'
. close sch_var

. FILE_PATH = LARAVEL_MODELS_DIR + 'Schema_table' + '.php'
. open sch_table / dsnvar = FILE_PATH /write iostat = IO_FEEDBACK lrecl=3000
.   write (sch_table) '<?php'
.   write (sch_table) 'class Schema_table  extends Eloquent {'
.   write (sch_table) "protected $table = 'Schema_table';"
.   write (sch_table) '}'
.   write (sch_table) '?>'
. close sch_table


. FILE_PATH = LARAVEL_MODELS_DIR + 'Schema_value_labels' + '.php'
. open val_labs / dsnvar = FILE_PATH /write iostat = IO_FEEDBACK lrecl=3000
.   write (val_labs) '<?php'
.   write (val_labs) 'class Schema_value_labels extends Eloquent {'
.   write (val_labs) "protected $table = 'schema_value_labels';"
.   write (val_labs) '}'
.   write (val_labs) '?>'
. close val_labs
end program
END PROCEDURE
