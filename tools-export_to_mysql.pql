PROCEDURE      TOOLS.EXPORT_TO_MYSQL:T  (157780,52651)  |Last amended Oct 09, 2014,14:37:31
c TRANSFER SIR DATA TO A MYSQL DATABASE.

GLOBAL username   = dcd
GLOBAL password   = dcd
global redcap     = yes
GLOBAL new        = no
GLOBAL STOP_REC   = 1 | DON'T SET THIS TO GET ALL RECORD TYPES
global NULL_VALUE = '' | NULL
global date_format = 'mm/dd/yyyy'  |  'yyyy-mm-dd'
global time_format = 'hh:mm'    |  'hh:mm:ss'
GLOBAL G_CONTINUE = 0  | 0=Do Not Continue   1=Continue
global CASE_RESTRICTION = ' COUNT = 25'
| global CASE_RESTRICTION = 'SAMPLE_SIZE = 1'
global WINDOWS_MACHINE = 1
global LINE_TERMINATOR = '\n'

C -------------------------------------------------------------------------------------------------------------
C -------------------------------------------------------------------------------------------------------------
C SET WINDOWS LINE TERMINATOR
PROGRAM
. integer * 1 T
. T = globaln ( 'CASE_SEEDER', NOW(0) )
. IFTHEN  ( 0<WINDOWS_MACHINE> EQ 1 )
.   T = globals ( 'LINE_TERMINATOR', '\r\n' )  | WINDOWS END OF LINE.  change according to your system.
.   WRITE 'PATHS TO WINDOWS FILE WILL BE HAVE THE BACKSLASH (SQL KEYWORD) ESCAPED.  LOOK FOR DOUBLE BACKSLASHES '/
. ENDIF
END PROGRAM

c choose either tab deliminator or comma separator
program
. string  * 4 FILE_ENDING  | "csv, tab"
. integer * 1 T

| set the file ending and everything else will be set.  |add new options when needed.
. FILE_ENDING = "csv"
.
. IFTHEN  ( lower( FILE_ENDING ) EQ 'tab' )
.   T = globals ( 'FILE_ENDING', 'tab' )
.   T = globals ( 'DELIMINATOR', char(9) )  | tab
.   T = globals ( 'SQL_DELIMINATOR', '\t' )  | tab
.   T = globals ( 'PQL_DELIMINATOR', 'char(9)' )  | tab

. elseif   ( lower( FILE_ENDING ) EQ 'csv' )
.   T = globals ( 'FILE_ENDING', 'csv' )
.   T = globals ( 'DELIMINATOR', char(44) )
.   T = globals ( 'SQL_DELIMINATOR', ',' )
.   T = globals ( 'PQL_DELIMINATOR', 'char(44)' )
. else
.   write /////'  !!!!! A BIG MISTAKE HAPPENED.  PLEASE CHOOSE A FILE ENDING  !!!!!  ///'
. ENDIF
end program


C -------------------------------------------------------------------------------------------------------------
C -------------------------------------------------------------------------------------------------------------
Program
write 'Your settings are' /
      5t 'SEED = <CASE_SEEDER>' /
      5t 'SAMPLE SIZE = <SAMPLE_SIZE>'  /
      5t 'USERNAME = <USERNAME>' /
      5t 'PASSWORD = <PASSWORD>' /
      5t 'NEW = <NEW> ' /
      5t 'CASE_RESTRICTION = <CASE_RESTRICTION>' /
      5t 'WINDOWS MACHINE= <WINDOWS_MACHINE>' /
      5t 'LINE TERMINATOR= <LINE_TERMINATOR>' /
      5t 'redcap= <redcap>' /

end program


PRINT BACK OFF
PRINT BACK REMARKS


C -------------------------------------------------------------------------------------------------------------
C -------------------------------------------------------------------------------------------------------------
c create OUTPUT FOLDER
program CRWARN
. string  *  250   OUTPUT_DIR DIR$
. string  *  250   FILE_PATH FILE_NAME
. STRING  *    6   FILE_EXT
. INTEGER *    2   EACH_CHAR
. integer *    1   PASSFAIL
. string  *  300   DBMS_LINE

. OUTPUT_DIR = dsn( 'prefix' )  +  'to_mysql\'
. execute SUBROUTINE SYSPROC.TOOLS.FILENAME ( OUTPUT_DIR ) RETURNING ( FILE_PATH, FILE_NAME, FILE_EXT )

. for EACH_CHAR = 1, len(  FILE_PATH  )
.   IF (  sbst(  FILE_PATH , EACH_CHAR, 2 ) = ':' ) NEXT FOR  | EXCEPTION FOR c:\
.   IF (  FILEIS(  SBST(  FILE_PATH, 1, EACH_CHAR )  ) EQ -1 ) NEXT FOR | FOLDER ALREADY EXISTS
.   IFTHEN (  sbst( FILE_PATH , EACH_CHAR, 1 ) EQ "\"  )
.     DIR$ = SBST( FILE_PATH, 1, EACH_CHAR )
.     PASSFAIL = makedir( DIR$ )
.     if ( PASSFAIL  EQ 0 ) EXIT FOR
.   ENDIF
. end for

. ifthen ( FILEIS( OUTPUT_DIR  ) EQ -1  )
.   write 'Excellent: Output folder created: ' OUTPUT_DIR
. else
.   write 'FAILED TO MAKE NECESSARY OUTPUT FOLDER: ' OUTPUT_DIR
C .   pql exit dbms
. endif
. DBMS_LINE = 'set attribute output_dir = "' + OUTPUT_DIR + '"'
. execute dbms DBMS_LINE

end program

C -------------------------------------------------------------------------------------------------------------
C -------------------------------------------------------------------------------------------------------------
c create database schema and keys constraints
program
. STRING  *  300   CREATE_DB_FILE
. string  *  300   REDCAP_FILE
. string  * 2000   REDCAP_CSV_LINE
. string  * 2000   REDCAP_VALLABS
. STRING  *  300   CREATE_CONSTRAINT_FILE
. INTEGER *    4   IO_FEEDBACK
. INTEGER *    4   Z_DUMMY
. INTEGER *    4   STOP_REC
. STRING  *  300   CHECK_WORD
. STRING  *  300   CLEAN_WORD
. STRING  *  300   CHECK_FILE
. integer *    1   THIS_VTYPE
. STRING  *   32   THIS_VAR_SQL_TYPE
. STRING  *   32   THIS_VAR_REDCAP_TYPE
. string  *   32   THIS_VARMIN THIS_VARMAX
. integer *    4   THIS_VARLENG
. STRING  *  300   THIS_LINE
. integer *    4   EACH_REC   EACH_VAR  EACH_KEY
. INTEGER *    2   Z_INDS
. INTEGER *    4   EACH_INDEX  EACH_INDEX_VAR
. INTEGER *    4   MAX_INDEX_VAR
. INTEGER *    1   MYSQL_RESERVED   | IS IT A RESERVED WORD IN MYSQL?  BOOLEAN


. Z_INDS = dbinds( 0 )

. STOP_REC = fst ( nglobal( 'STOP_REC'), nrecs (0) )

. compute CREATE_DB_FILE   =  DSN('OUTPUT_DIR') +  '01_' + trim( '<DBNAME>' ) + "_db_create.sql"
. open f_db_create / dsnvar = CREATE_DB_FILE  /write iostat = IO_FEEDBACK lrecl=3000
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CREATE_DB_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
.   EXIT PROGRAM
. ELSE
.   WRITE 'f_db_created: '  CREATE_DB_FILE /
. ENDIF

. write( f_db_create ) 'CREATE DATABASE <DBNAME> ;'
. write( f_db_create ) 'USE <DBNAME> ;' /
. write( f_db_create ) '#################################'
. write( f_db_create ) '## Database Settings-> dbmeta  ##' //
. write( f_db_create ) 'CREATE TABLE db_config ('
                       'db_name VARCHAR( 30 )  NOT NULL,'
                       'db_label VARCHAR ( 100 ),'
                       'db_type INTEGER ,'
. write( f_db_create ) ')' |end db_config

| system config
. write( f_db_create ) 'CREATE TABLE system_config ('
                       'system_offline INTEGER NOT NULL,'
                       'system_version VARCHAR ( 100 ),'
. write( f_db_create ) ')' |end system_config


c??  should user informaiton be "usermeta" instead and be structured Umeta_id (key), user_id, meta_key, meta_value?????
| user information
. write( f_db_create ) 'CREATE TABLE user_information ('
                       'user_id INTEGER NOT NULL,'
                       'user_login VARCHAR ( 100 ),'
                       'user_password VARCHAR ( 100 ),'
                       'remember_token VARCHAR ( 100 ),'
                       'user_email VARCHAR ( 100 ),'
                       'user_first_name VARCHAR ( 100 ),'
                       'user_last_name VARCHAR ( 100 ),'
                       'user_registered DATE,'
                       'user_status INTEGER,'
                       'user_first_active DATE,'
                       'user_last_active DATE,'
. write( f_db_create ) ')' |end user information



. write( f_db_create ) '#################################'
. write( f_db_create ) '## Record Types->Tables      ####' //




. for EACH_REC = 1, STOP_REC
.   compute THIS_REC_NAME = trim( lower( recname( EACH_REC ) ) )
.   CHECK_WORD = THIS_REC_NAME
.   EXECUTE SUBPROCEDURE CHECK_RESERVED_WORDS  | CHECK TABLE NAME FOR RESERVERED WORDS
.   THIS_LINE = 'CREATE TABLE ' + CLEAN_WORD + ' ('
.   write ( f_db_create ) THIS_LINE
.   for EACH_VAR = 1, nvarsc( EACH_REC )
.     compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )

.     CHECK_WORD = THIS_VAR_NAME
.     EXECUTE SUBPROCEDURE CHECK_RESERVED_WORDS  | CHECK TABLE NAME FOR RESERVERED WORDS
.     compute THIS_VTYPE = vtype( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )
.     compute THIS_VARLENG = varleng( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )

.     recode THIS_VAR_SQL_TYPE = THIS_VTYPE( 1 = 'VARCHAR' ) ( 2 = 'VARCHAR' ) ( 3 = 'DATE' ) ( 4 = 'TIME' ) ( 5 = 'INTEGER' )
                     ( 6 = 'FLOAT' )( 7 = 'DOUBLE PRECISION' ) ( 8 = 'BIGINT' )
.     THIS_LINE = CLEAN_WORD + '  ' + THIS_VAR_SQL_TYPE


.     ifthen( THIS_VAR_SQL_TYPE = 'VARCHAR' )
.       THIS_LINE = THIS_LINE  + '( ' + format( THIS_VARLENG ) + ' )'
.     endif

.     for EACH_KEY = 1, nkeys( EACH_REC ) + dbtype(0)
.       ifthen ( THIS_VAR_NAME EQ lower( trim( keyname( EACH_REC, EACH_KEY ) ) ) )
.         THIS_LINE = THIS_LINE + '  NOT NULL'
.       endif
.     end for

.     if (  EACH_VAR lt nvarsc( EACH_REC ) ) THIS_LINE = THIS_LINE  + ', '

.     write ( f_db_create ) 2T THIS_LINE

.     if (  EACH_VAR eq nvarsc( EACH_REC ) ) write( f_db_create ) ' ) ;'
.   end for
. end for


c variable constraints
. compute CREATE_CONSTRAINT_FILE   =  DSN('OUTPUT_DIR') +  '01_' + trim( '<DBNAME>' ) + "_db_constraints.sql"
. open f_constr / dsnvar = CREATE_CONSTRAINT_FILE  /write iostat = IO_FEEDBACK lrecl=3000
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CREATE_CONSTRAINT_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
.   EXIT PROGRAM
. ELSE
.   WRITE 'Awesome: made f_constr file : '  CREATE_CONSTRAINT_FILE /
. ENDIF

. write( f_constr ) '###############################'
. write( f_constr ) '## add primary keys          ##' /
. for EACH_REC = 1, STOP_REC
.   compute THIS_REC_NAME = trim( lower( recname( EACH_REC ) ) )
.   CHECK_WORD = THIS_REC_NAME
.   execute SUBPROCEDURE CHECK_RESERVED_WORDS
.   write( f_constr ) // 'alter table ' CLEAN_WORD

.   compute THIS_LINE = 'add constraint ' + THIS_REC_NAME
.   for EACH_KEY = 1, nkeys( EACH_REC ) + DBTYPE(0)
.     compute THIS_LINE = THIS_LINE + '_' + trim( keyname( EACH_REC, EACH_KEY ) )
.   end for
.   compute THIS_LINE = THIS_LINE + '_pk primary key ( '
.   for EACH_KEY = 1, nkeys( EACH_REC ) + DBTYPE(0)
.     CHECK_WORD = trim( keyname( EACH_REC, EACH_KEY ) )
.     execute SUBPROCEDURE CHECK_RESERVED_WORDS
.     compute THIS_LINE = THIS_LINE + CLEAN_WORD
.     if (EACH_KEY lt nkeys( EACH_REC ) + DBTYPE(0) ) compute THIS_LINE = THIS_LINE + ', '
.   end for
.   compute THIS_LINE = THIS_LINE + ' );'
.   write( f_constr ) THIS_LINE  /
. end for
. write( f_constr ) '###############################'
. write( f_constr ) '## Create secondary indexes; ##' //

. for EACH_INDEX = 1, Z_INDS
.   compute MAX_INDEX_VAR = dbindv( EACH_INDEX )
.   compute THIS_LINE = 'create index ' + dbindn( EACH_INDEX ) + ' on ' +
                        trimr( lower( recname( dbindr( EACH_INDEX ) ) ) ) + '( '
.   for EACH_INDEX_VAR = 1, MAX_INDEX_VAR
.     CHECK_WORD = pack( dbindt( EACH_INDEX, EACH_INDEX_VAR ) )
.     EXECUTE SUBPROCEDURE CHECK_RESERVED_WORDS  | CHECK TABLE NAME FOR RESERVERED WORDS
.     THIS_LINE = THIS_LINE + CLEAN_WORD
.     IF (EACH_INDEX_VAR LT MAX_INDEX_VAR ) THIS_LINE = THIS_LINE + ', '
.   end for
.   THIS_LINE = THIS_LINE + ' );'
.   write( f_constr ) THIS_LINE
. end for
. close ( f_db_create )
. close ( f_constr )


c   EXPORT TO REDCAP SECTION
cif eq '<redcap>', 'yes'
. compute REDCAP_FILE   =  DSN('OUTPUT_DIR') +  '01_' + trim( '<DBNAME>' ) + "_redcap.csv"
. open redcap / dsnvar = REDCAP_FILE /write iostat = IO_FEEDBACK lrecl=3000
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' REDCAP_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
.   EXIT PROGRAM
. ELSE
.   WRITE 'redcap: '  REDCAP_FILE /
. ENDIF
| THE REDCAP HEADERS ARE NECCESSARY FOR IMPORT.  REDCAP AUTOMATICALLY IGNORES THE FIRST LINE OF THE FILE
. THIS_LINE =  'Variable / Field Name,Form Name,Section Header,Field Type,Field Label,' +
               '"Choices, Calculations, OR Slider Labels",Field Note,' +
               'Text Validation Type OR Show Slider Number,Text Validation Min,Text Validation Max,' +
               'Identifier?,Branching Logic'
. write( redcap )
. for EACH_REC = 1, STOP_REC
.   compute THIS_REC_NAME = trim( lower( recname( EACH_REC ) ) )
.   for EACH_VAR = 1, nvarsc( EACH_REC )
.     compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.     compute THIS_VTYPE    = vtype( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )
.     compute THIS_VARLENG  = varleng( EACH_REC, varnamec( EACH_REC, EACH_VAR ) )
.     compute THIS_VARLAB   = varlabsc ( EACH_REC, THIS_VAR_NAME )
.     compute THIS_VARMIN   = FST( FORMAT( NMIN( EACH_REC, THIS_VAR_NAME) ), SMIN ( EACH_REC, THIS_VAR_NAME ), '' )
.     compute THIS_VARMAX   = FST( FORMAT( NMAX( EACH_REC, THIS_VAR_NAME) ), SMAX ( EACH_REC, THIS_VAR_NAME ), '' )

.     ifthen (THIS_VTYPE eq 3)
.       if ( THIS_VARMIN EQ '1' ) THIS_VARMIN = ''
.       if ( THIS_VARMIN EQ '3660000' ) THIS_VARMIN = ''
.       if ( THIS_VARMAX EQ '1' ) THIS_VARMAX = ''
.       if ( THIS_VARMAX EQ '3660000' ) THIS_VARMAX = ''
.       THIS_VARMIN = fst( datec( numbr(THIS_VARMIN), '<date_format>'), '')
.       THIS_VARMAX = fst( datec( numbr(THIS_VARMAX), '<date_format>'), '')
.     elseif (THIS_VTYPE eq 4)
.       THIS_VARMIN = TIMEC( numbr(THIS_VARMIN), '<time_format>')
.       THIS_VARMAX = TIMEC( numbr(THIS_VARMAX), '<time_format>')
.     endif

.     recode  THIS_VAR_REDCAP_TYPE = THIS_VTYPE( 1 = '' ) ( 2 = '' ) ( 3 = 'date' ) ( 4 = 'time' ) ( 5 = 'integer' )
                     ( 6 = 'number' )( 7 = 'number' ) ( 8 = 'number' )
.     ifthen ( nvallab( EACH_REC,  THIS_VAR_NAME) lt 2)
.       THIS_FIELD_TYPE = 'text'
.     elseif ( nvallab( EACH_REC,  THIS_VAR_NAME) eq 2)
.       THIS_FIELD_TYPE = 'radio'
.     else
.       THIS_FIELD_TYPE = 'dropdown'
.     endif

| crazy field min and maxs must be removed if it is a drop down or radio.  ONLY TEXT can have mins and maxs
| for radios and dropdowns there is no field type either!
.     ifthen ( THIS_FIELD_TYPE eq 'radio' or 'dropdown' )
.       THIS_VARMIN = ''
.       THIS_VARMAX = ''
.       THIS_VAR_REDCAP_TYPE = ''
.     endif


|     value labels
.     REDCAP_VALLABS = '"'
.     for EACH_LABEL = 1, nvallab( EACH_REC,  THIS_VAR_NAME)
.       REDCAP_VALLABS = REDCAP_VALLABS + trim( pack( VALLABSV( EACH_REC, THIS_VAR_NAME, EACH_LABEL ) ) )
.       REDCAP_VALLABS = REDCAP_VALLABS + ', '
.       REDCAP_VALLABS = REDCAP_VALLABS + trim( pack( VALLABSN( EACH_REC, THIS_VAR_NAME ,EACH_LABEL ) ) )
.       if (EACH_LABEL lt  nvallab( EACH_REC,  THIS_VAR_NAME) ) REDCAP_VALLABS = REDCAP_VALLABS +  ' | '
.     end for
.     REDCAP_VALLABS = REDCAP_VALLABS + '"'


.     REDCAP_CSV_LINE = THIS_VAR_NAME + ',' +
                    THIS_REC_NAME + ',' +
                    ',' +
                    THIS_FIELD_TYPE + ',' +
                    THIS_VARLAB + ',' +
                    REDCAP_VALLABS + ',' +
                    ',' +
                    THIS_VAR_REDCAP_TYPE + ',' +
                    THIS_VARMIN + ',' + THIS_VARMAX + ',' +
                    ',' +
                    ',' +
                    ',' +
                    ',' +
                    ','
.     write( redcap ) REDCAP_CSV_LINE
.   end for
. end for
CLOSE (REDCAP)
cif end

SUBPROCEDURE CHECK_RESERVED_WORDS
C CHECK TO SEE IF A VARIABLE IS A RESERVED WORD IN MYSQL
. MYSQL_RESERVED = 0
. CHECK_WORD = trim( upper( CHECK_WORD ) )
. CLEAN_WORD = CHECK_WORD
. DO REPEAT RESERVED_WORD =
    ACCESSIBLE ADD ALL ALTER ANALYZE AND AS ASC ASENSITIVE
    BEFORE BETWEEN BIGINT BINARY BLOB BOTH BY
    CALL CASCADE CASE CHANGE CHAR CHARACTER CHECK COLLATE COLUMN CONDITION CONSTRAINT CONTINUE CONVERT CREATE
    CROSS CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER CURSOR
    DATABASE DATABASES DAY_HOUR DAY_MICROSECOND DAY_MINUTE DAY_SECOND DEC DECIMAL DECLARE DEFAULT DELAYED DELETE
    DESC DESCRIBE DETERMINISTIC DISTINCT DISTINCTROW DIV DOUBLE DROP DUAL
    EACH ELSE ELSEIF ENCLOSED ESCAPED EXISTS EXIT EXPLAIN
    FALSE FETCH FLOAT FLOAT4 FLOAT8 FOR FORCE FOREIGN FROM FULLTEXT
    GRANT GROUP HAVING HIGH_PRIORITY HOUR_MICROSECOND HOUR_MINUTE HOUR_SECOND
    IF IGNORE IN INDEX INFILE INNER INOUT INSENSITIVE INSERT INT INT1 INT2 INT3 INT4 INT8 INTEGER INTERVAL INTO IS ITERATE
    JOIN KEY KEYS KILL LEADING LEAVE LEFT LIKE LIMIT LINEAR LINES LOAD LOCALTIME
    LOCALTIMESTAMP LOCK LONG LONGBLOB LONGTEXT LOOP LOW_PRIORITY
    MASTER_SSL_VERIFY_SERVER_CERT MATCH MAXVALUE MEDIUMBLOB MEDIUMINT MEDIUMTEXT MIDDLEINT
    MINUTE_MICROSECOND MINUTE_SECOND MOD MODIFIES
    NATURAL NOT NO_WRITE_TO_BINLOG NULL NUMERIC ON OPTIMIZE OPTION OPTIONALLY OR ORDER OUT OUTER OUTFILE
    PRECISION PRIMARY PROCEDURE PURGE
    RANGE READ READS READ_WRITE REAL REFERENCES REGEXP RELEASE RENAME REPEAT
    REPLACE REQUIRE RESIGNAL RESTRICT RETURN REVOKE RIGHT RLIKE
    SCHEMA SCHEMAS SECOND_MICROSECOND SELECT SENSITIVE SEPARATOR SET SHOW
    SIGNAL SMALLINT SPATIAL SPECIFIC SQL SQLEXCEPTION SQLSTATE SQLWARNING
    SQL_BIG_RESULT SQL_CALC_FOUND_ROWS SQL_SMALL_RESULT SSL STARTING STRAIGHT_JOIN
    TABLE TERMINATED THEN TINYBLOB TINYINT TINYTEXT $TO$ TRAILING TRIGGER TRUE
    UNDO UNION UNIQUE UNLOCK UNSIGNED UPDATE USAGE USE USING UTC_DATE UTC_TIME UTC_TIMESTAMP
    VALUES VARBINARY VARCHAR VARCHARACTER VARYING WHEN
    WHERE WHILE WITH WRITE XOR YEAR_MONTH ZEROFILL
.   IFTHEN ( CHECK_WORD EQ 'RESERVED_WORD' )
.     CLEAN_WORD = "`" + CLEAN_WORD + "`"
.     MYSQL_RESERVED = 1; write // 'WARNING!!! mysql reserved word in schema: RESERVED_WORD' //; EXIT SUBPROCEDURE
.   ENDIF
. END REPEAT
END SUBPROCEDURE

end program

C -------------------------------------------------------------------------------------------------------------
C -------------------------------------------------------------------------------------------------------------
c create talbes to hold variable information that is held in SIR but is not stored in MySQL
program
. STRING  *  300   Z_VAR_SCHEMA  Z_VAR_SCHEMA_DATA
. STRING  *  300   Z_VALUE_LABELS  Z_VALUE_LABEL_DATA
. string  *  300   THIS_REC_NAME   THIS_VAR_NAME
. integer *    1   THIS_VTYPE
. integer *    4   EACH_REC   EACH_VAR    THIS_VARLENG   EACH_KEY
. INTEGER *    1   MYSQL_RESERVED   | IS IT A RESERVED WORD IN MYSQL?  BOOLEAN
. STRING  *  300   CHECK_WORD  CHECK_FILE
. STRING  *  300   CLEAN_WORD
. STRING  *  300   CSV_VALUE
. STRING  *  3000  CSV_LINE
. INTEGER *    4   IO_FEEDBACK
. STRING  *  200   MYSQL_FILENAME   | JUST INCASE THE FILE NAME FOR DATA IMPORT NEEDS TO BE MANIPULATED BASED ON THE SYSTEM
. STRING  *    6   LINE_TERMINATOR
. integer *    4   STOP_REC        | What record number should this stop at.  Used for sampling and testing.

. STOP_REC = fst ( nglobal( 'STOP_REC'), nrecs (0) )
. LINE_TERMINATOR = '<LINE_TERMINATOR>'

compute Z_VAR_SCHEMA        =  DSN('OUTPUT_DIR') +  '02_' + trim( '<DBNAME>' ) + "_var_schema.sql"
compute Z_VAR_SCHEMA_DATA   =  DSN('OUTPUT_DIR') +  '03_' + trim( '<DBNAME>' ) + "_var_schema_data.csv"
compute Z_VALUE_LABELS      =  DSN('OUTPUT_DIR') +  '04_' + trim( '<DBNAME>' ) + "_value_label_schema.sql"
compute Z_VALUE_LABEL_DATA  =  DSN('OUTPUT_DIR') +  '05_' + trim( '<DBNAME>' ) + "_value_label_data.csv"


DO REPEAT EACH_FILENAME = F_VAR_SCHEMA  F_VAR_SCHEMA_DATA  F_VALUE_LABELS   F_VALUE_LABEL_DATA  /
          EACH_PATH =     Z_VAR_SCHEMA  Z_VAR_SCHEMA_DATA  Z_VALUE_LABELS   Z_VALUE_LABEL_DATA

. open EACH_FILENAME / dsnvar = EACH_PATH  /write iostat = IO_FEEDBACK lrecl=3000
. CHECK_FILE = EACH_PATH
. execute subprocedure CHECK_IO
end repeat


c variable details
write( F_VAR_SCHEMA ) 'CREATE TABLE SCHEMA_VARIABLE (' /
                     'ID int NOT NULL AUTO_INCREMENT,' /
                     'TABLE_NAME varchar(255),' /
                     'VARIABLE_NAME varchar(255),' /
                     'VARIABLE_LABEL varchar(255),' /
                     'VARIABLE_DOCUMENT varchar(255),' /
                     'VARIABLE_READ_SECURITY varchar(255),' /
                     'VARIABLE_WRITE_SECURITY varchar(255),' /
                     'VARIABLE_STATTYPE varchar(255),' /
                     'VARIABLE_TYPE varchar(255),' /
                     'VARIABLE_LENGTH varchar(255),' /
                     'VARIABLE_SCALE varchar(255),' /
                     'VARIABLE_MISSING1 varchar(255),' /
                     'VARIABLE_MISSING2 varchar(255),' /
                     'VARIABLE_MISSING3 varchar(255),' /
                     'VARIABLE_RANGE_MIN varchar(255),' /
                     'VARIABLE_RANGE_MAX varchar(255),' /
                     'VARIABLE_VALID_VALUE varchar(255),' /
                     'PRIMARY KEY (ID)' /
                     ');' /

MYSQL_FILENAME = Z_VAR_SCHEMA_DATA
EXECUTE SUBPROCEDURE ESCAPE_SLASHES
write ( f_VAR_SCHEMA ) 'LOAD DATA LOCAL ' /
                          ["INFILE '" + MYSQL_FILENAME  + "'" ] /
                          'INTO TABLE SCHEMA_VARIABLE' /
                          "COLUMNS TERMINATED BY ','" /
			  "OPTIONALLY ENCLOSED BY '""'"/
			  "ESCAPED BY '""'"/
			  "LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                          "IGNORE 1 LINES;"/

c value labels table
write( f_value_labels ) 'CREATE TABLE SCHEMA_VALUE_LABELS ('
                     'ID int NOT NULL AUTO_INCREMENT,'
                     'TABLE_NAME varchar(255),'
                     'VARIABLE_NAME varchar(255),'
                     'VALUE varchar(255),'
                     'VALUE_LABEL varchar(255),'
                     'PRIMARY KEY (ID)'
                     ');'
MYSQL_FILENAME = Z_value_label_data
EXECUTE SUBPROCEDURE ESCAPE_SLASHES
write ( f_value_labels ) 'LOAD DATA LOCAL ' /
                          ["INFILE '" + MYSQL_FILENAME + "'" ] /
                          'INTO TABLE SCHEMA_VALUE_LABELS' /
                          "COLUMNS TERMINATED BY ','" /
                          "OPTIONALLY ENCLOSED BY '""'"/
                          "ESCAPED BY '""'"/
			  "LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                          "IGNORE 0 LINES;"/



WRITE ( F_VAR_SCHEMA_DATA ) '"ID,TABLE_NAME","VARIABLE_NAME","VARIABLE_LABEL","VARIABLE_DOCUMENT",'
                            '"VARIABLE_READ_SECURITY","VARIABLE_WRITE_SECURITY",'
                            '"VARIABLE_STATTYPE","VARIABLE_TYPE","VARIABLE_LENGTH","VARIABLE_SCALE",'
                            '"VARIABLE_MISSING1","VARIABLE_MISSING2","VARIABLE_MISSING3",'
                            '"VARIABLE_RANGE_MIN","VARIABLE_RANGE_MAX","VARIABLE_VALID_VALUE"'


write 'Files created ' / 'f_VAR_SCHEMA: '       [ dsn( 'f_VAR_SCHEMA' ) ] /
                         'f_VAR_SCHEMA_data: '  [ dsn( 'f_VAR_SCHEMA_data' ) ] /
                         'f_value_labels: '     [ dsn( 'f_value_labels' ) ] /
                         'f_value_label_data: ' [ dsn( 'f_value_label_data' ) ] /

for EACH_REC = 1, STOP_REC
. compute THIS_REC_NAME = trim( lower( recname( EACH_REC ) ) )
. if( exists( THIS_REC_NAME ) eq 0 ) next for
. for EACH_VAR = 1, nvarsc( EACH_REC )
.   compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.   compute THIS_VTYPE    = vtype( EACH_REC, THIS_VAR_NAME )
.   compute THIS_VARLENG  = varleng( EACH_REC, THIS_VAR_NAME )

.   recode THIS_VAR_SQL_TYPE = THIS_VTYPE( 1 = 'VARCHAR' )( 2 = 'VARCHAR' )( 3 = 'DATE' )( 4 = 'TIME' )( 5 = 'INTEGER' )
    ( 6 = 'FLOAT' )( 7 = 'DOUBLE PRECISION' )( 8 = 'BIGINT' )

c   variable schema
.   CSV_LINE = "0,"
.   CHECK_WORD = THIS_REC_NAME
.   EXECUTE SUBPROCEDURE CHECK_RESERVED_WORDS
.   CSV_LINE = CSV_LINE + '"' + CLEAN_WORD + '",'  |table name

.   CHECK_WORD = THIS_VAR_NAME
.   EXECUTE SUBPROCEDURE CHECK_RESERVED_WORDS
.   CSV_LINE = CSV_LINE + '"' + CLEAN_WORD + '",'  | variable name

C   - VARIABLE LABEL
.   CSV_VALUE = VARLABSC ( EACH_REC, THIS_VAR_NAME )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE;

C   - VARIABLE DOCUMENT
.   CSV_VALUE = ""
.   FOR EACH_LINE = 1, NVARDOC ( EACH_REC, THIS_VAR_NAME )
.     CSV_VALUE = CSV_VALUE + VARDOCSN ( EACH_REC, THIS_VAR_NAME, EACH_LINE )
.   END FOR
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_READ_SECURITY
.   CSV_VALUE = FORMAT( RVARSEC( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_WRITE_SECURITY
.   CSV_VALUE = FORMAT( WVARSEC( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_STATTYPE 0=None, 1=Observation, 2=Control
.   CSV_VALUE = FORMAT( STATTYPE ( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_TYPE
.   CSV_VALUE = FORMAT( VTYPE    ( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   -  VARIABLE_LENGTH  FOR STRINGS
.   CSV_VALUE = FORMAT( VARLENG  ( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_SCALE
.   CSV_VALUE = FORMAT( VSCALE   ( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_MISSING1
.   CSV_VALUE = MISS     ( EACH_REC, THIS_VAR_NAME, 1 )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_MISSING2
.   CSV_VALUE = MISS     ( EACH_REC, THIS_VAR_NAME, 2 )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_MISSING3
.   CSV_VALUE = MISS     ( EACH_REC, THIS_VAR_NAME, 3 )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_RANGE_MIN
.   CSV_VALUE = FST( FORMAT( NMIN( EACH_REC, THIS_VAR_NAME) ), SMIN ( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C   - VARIABLE_RANGE_Max
.   CSV_VALUE = FST( FORMAT( NMAX( EACH_REC, THIS_VAR_NAME) ), SMAX ( EACH_REC, THIS_VAR_NAME ) )
.   EXECUTE SUBPROCEDURE MAKE_FILE_LINE

C  COME BACK ON WORK ON THIS.  SHOULD IT BE A COMMA SEPARATED LIST?  CHECK OUT HOW WORDPRESS AND JOOMLA HANDLE THINGS LIKE THIS
C.   WRITE ( f_value_label_data/noeol ) VARIABLE_VALID_VALUE
.   EXECUTE SUBPROCEDURE TRIM_LAST_COMMA
.   WRITE ( f_VAR_SCHEMA_data ) CSV_LINE

C ------------------
C -  VALUE LABELS  -
.   CSV_LINE = ''
.   for EACH_LABEL = 1, nvallab( EACH_REC,  THIS_VAR_NAME)
.     CSV_LINE = '0,'
.     CSV_VALUE = THIS_REC_NAME; EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     CSV_VALUE = THIS_VAR_NAME; EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     CSV_VALUE = VALLABSV ( EACH_REC, THIS_VAR_NAME, EACH_LABEL ); EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     CSV_VALUE = VALLABSN( EACH_REC, THIS_VAR_NAME ,EACH_LABEL ) ; EXECUTE SUBPROCEDURE MAKE_FILE_LINE
.     EXECUTE SUBPROCEDURE TRIM_LAST_COMMA
.     WRITE ( f_value_label_data ) CSV_LINE
.   end for


. END FOR
END FOR

close ( f_VAR_SCHEMA )
close ( f_VAR_SCHEMA_data )
close ( f_value_labels )
close ( f_value_label_data)


SUBPROCEDURE CHECK_IO
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CHECK_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
. ENDIF
END SUBPROCEDURE

subprocedure MAKE_FILE_LINE
C CREATE A LINE THAT CAN BE READ IN BY MYSQL
. IF ( EXISTS( CSV_LINE ) EQ 0 ) CSV_LINE = ""
. CSV_VALUE =  replace( CSV_VALUE, '"', '""', 99, 2, 0 ) | 2 double qoutes when imported turn into 1 double qoute
. CSV_VALUE =  replace( CSV_VALUE, "’", "'", 99, 2, 0 )  | There is an issue with the back qoutes and importing into MySQL`

. IFTHEN ( EXISTS( CSV_VALUE ) EQ 0)
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( pack( trimlr( CSV_VALUE ) ) EQ '' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( CSV_VALUE EQ 'NULL' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSE
.   CSV_VALUE =  '"' + TRIMR( CSV_VALUE) + '"'       | ADD QOUTES AND GET RID OF TRAILING SPACES
. ENDIF

. CSV_LINE = CSV_LINE + CSV_VALUE + '<DELIMINATOR>'
end subprocedure

SUBPROCEDURE TRIM_LAST_COMMA
. CSV_LINE = TRIMR( CSV_LINE )
C . IF ( SUBSTR( CSV_LINE, LEN( CSV_LINE ), 1 ) EQ ',' ) CSV_LINE = SUBSTR( CSV_LINE, 1, LEN( CSV_LINE )  -1)
END SUBPROCEDURE

SUBPROCEDURE ESCAPE_SLASHES
c for windows the "\" in the file path must be escaped as it is a SQL reserved keyword
. IFNOT ( 0<WINDOWS_MACHINE> EQ 1 ) EXIT SUBPROCEDURE
. MYSQL_FILENAME = replace( MYSQL_FILENAME , '\', '\\', 99, 2, 0 )
END SUBPROCEDURE


SUBPROCEDURE CHECK_RESERVED_WORDS
C CHECK TO SEE IF A VARIABLE IS A RESERVED WORD IN MYSQL
. MYSQL_RESERVED = 0
. CHECK_WORD = trim( upper( CHECK_WORD ) )
. CLEAN_WORD = CHECK_WORD
. DO REPEAT RESERVED_WORD =
    ACCESSIBLE ADD ALL ALTER ANALYZE AND AS ASC ASENSITIVE
    BEFORE BETWEEN BIGINT BINARY BLOB BOTH BY
    CALL CASCADE CASE CHANGE CHAR CHARACTER CHECK COLLATE COLUMN CONDITION CONSTRAINT CONTINUE CONVERT CREATE
    CROSS CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER CURSOR
    DATABASE DATABASES DAY_HOUR DAY_MICROSECOND DAY_MINUTE DAY_SECOND DEC DECIMAL DECLARE DEFAULT DELAYED DELETE
    DESC DESCRIBE DETERMINISTIC DISTINCT DISTINCTROW DIV DOUBLE DROP DUAL
    EACH ELSE ELSEIF ENCLOSED ESCAPED EXISTS EXIT EXPLAIN
    FALSE FETCH FLOAT FLOAT4 FLOAT8 FOR FORCE FOREIGN FROM FULLTEXT
    GRANT GROUP HAVING HIGH_PRIORITY HOUR_MICROSECOND HOUR_MINUTE HOUR_SECOND
    IF IGNORE IN INDEX INFILE INNER INOUT INSENSITIVE INSERT INT INT1 INT2 INT3 INT4 INT8 INTEGER INTERVAL INTO IS ITERATE
    JOIN KEY KEYS KILL LEADING LEAVE LEFT LIKE LIMIT LINEAR LINES LOAD LOCALTIME
    LOCALTIMESTAMP LOCK LONG LONGBLOB LONGTEXT LOOP LOW_PRIORITY
    MASTER_SSL_VERIFY_SERVER_CERT MATCH MAXVALUE MEDIUMBLOB MEDIUMINT MEDIUMTEXT MIDDLEINT
    MINUTE_MICROSECOND MINUTE_SECOND MOD MODIFIES
    NATURAL NOT NO_WRITE_TO_BINLOG NULL NUMERIC ON OPTIMIZE OPTION OPTIONALLY OR ORDER OUT OUTER OUTFILE
    PRECISION PRIMARY PROCEDURE PURGE
    RANGE READ READS READ_WRITE REAL REFERENCES REGEXP RELEASE RENAME REPEAT
    REPLACE REQUIRE RESIGNAL RESTRICT RETURN REVOKE RIGHT RLIKE
    SCHEMA SCHEMAS SECOND_MICROSECOND SELECT SENSITIVE SEPARATOR SET SHOW
    SIGNAL SMALLINT SPATIAL SPECIFIC SQL SQLEXCEPTION SQLSTATE SQLWARNING
    SQL_BIG_RESULT SQL_CALC_FOUND_ROWS SQL_SMALL_RESULT SSL STARTING STRAIGHT_JOIN
    TABLE TERMINATED THEN TINYBLOB TINYINT TINYTEXT $TO$ TRAILING TRIGGER TRUE
    UNDO UNION UNIQUE UNLOCK UNSIGNED UPDATE USAGE USE USING UTC_DATE UTC_TIME UTC_TIMESTAMP
    VALUES VARBINARY VARCHAR VARCHARACTER VARYING WHEN
    WHERE WHILE WITH WRITE XOR YEAR_MONTH ZEROFILL
.   IFTHEN ( CHECK_WORD EQ 'RESERVED_WORD' )
.     CLEAN_WORD = "`" + CLEAN_WORD + "`"
.     MYSQL_RESERVED = 1; write // 'WARNING!!! mysql reserved word in schema: RESERVED_WORD' //; EXIT SUBPROCEDURE
.   ENDIF
. END REPEAT
END SUBPROCEDURE

end program


C -------------------------------------------------------------------------------------------------------------
C -------------------------------------------------------------------------------------------------------------


program crwarn
string  *  300   THIS_REC_NAME   THIS_VAR_NAME
STRING  *  300   Z_SQLFN  Z_DATFN
STRING  *  300   Z_LOADIT
STRING  *  300   Z_DATA
string  *  3000  THIS_LINE
string  *  300   BASE_DIR
INTEGER *    1   PASSFAIL
real    *    8   Z_DUMMY
integer *    1   THIS_VTYPE
integer *    4   EACH_REC   EACH_VAR    THIS_VARLENG   EACH_KEY
STRING  *   32   THIS_VAR_SQL_TYPE
STRING  *  100   Z_VTERM
INTEGER *    4   IO_FEEDBACK
INTEGER *    1   MYSQL_RESERVED   | IS IT A RESERVED WORD IN MYSQL?  BOOLEAN
STRING  *  200   MYSQL_FILENAME   | JUST INCASE THE FILE NAME FOR DATA IMPORT NEEDS TO BE MANIPULATED BASED ON THE SYSTEM
STRING  *  300   CHECK_WORD  CHECK_FILE
STRING  *  300   CLEAN_WORD
STRING  *  300   CSV_VALUE
STRING  *  3000  CSV_LINE
STRING  *    6   LINE_TERMINATOR
integer *    4   STOP_REC        | What record number should this stop at.  Used for sampling and testing.

LINE_TERMINATOR = '<LINE_TERMINATOR>'

STOP_REC = fst ( nglobal( 'STOP_REC'), nrecs (0) )

BASE_DIR = dsn( 'output_dir' )

compute Z_DATA    =  BASE_DIR +  trim( '<DBNAME>' ) + "_data.pql"
compute Z_LOADIT  =  BASE_DIR +  '07_' + trim( '<DBNAME>' ) + "_loadit"
compute Z_DUMMY   =  globals( "DATAPROG",  Z_DATA )
compute Z_DUMMY   =  globals( "LOADIT",  Z_LOADIT )
compute Z_DUMMY   =  globalN( "G_CONTINUE",  1) | RETRIEVAL EXECUTED.
C OPEN THE NECESSARY FILES

DO REPEAT EACH_FILENAME = F_LOADIT  F_DATA /
          EACH_PATH =     Z_LOADIT  Z_DATA

. open EACH_FILENAME / dsnvar = EACH_PATH  /write iostat = IO_FEEDBACK lrecl=3000
. CHECK_FILE = EACH_PATH
. execute subprocedure CHECK_IO
end repeat



write 'Files created ' / 'f_loadit: '           [ dsn( 'f_loadit' ) ] /
                         'f_data:   '           [ dsn( 'f_data' ) ] /
      '-------------------------' //


. write( f_loadit ) "#!/bin/sh"
. ifthen( '<NEW>' = 'no' )
.   write( f_loadit )["mysql --local-infile = 1 --database = <DBNAME> --password = <password> --user = <username> --execute = 'drop database <DBNAME>'"]
. endif
. write( f_loadit )["mysql --local-infile = 1 --password = <password> --user = <username> --execute = 'source " + dsn( 'f_db_create' ) + "'"]
. write( f_loadit )["mysql --local-infile = 1 --database = <DBNAME> --password = <password> --user = <username> --execute = 'source " + DSN( 'f_constr' ) + "'"]

for EACH_REC = 1, STOP_REC
. compute THIS_REC_NAME = trim( lower( recname( EACH_REC ) ) )
. if( exists( THIS_REC_NAME ) eq 0 ) next for
. compute Z_SQLFN = BASE_DIR +  trim( '<DBNAME>' ) + '_rec_' + THIS_REC_NAME + '.sql'
. compute Z_DATFN = BASE_DIR +  trim( '<DBNAME>' ) + '_rec_' + THIS_REC_NAME + '.<FILE_ENDING>'
. write( f_data ) 'remark "Creating Rec# ' EACH_REC ': ' THIS_REC_NAME '"'
. write( f_data ) 'remark "' Z_SQLFN  '"'
. write( f_data ) 'remark "' Z_DATFN  '"'
. write( f_data ) // 'RETRIEVAL SEED = <CASE_SEEDER> |' EACH_REC ': ' THIS_REC_NAME
. write( f_data ) 'string * 4094  DATA_LINE'
. write( f_data ) 'string * 4094  DATA_VALUE'

. write( f_loadit )["mysql --local-infile = 1 --database = <DBNAME> --password = <password> --user = <username> --execute = 'source " + Z_SQLFN + "'"]
. open f_zsqlfn / dsnvar = Z_SQLFN / write

. MYSQL_FILENAME = Z_DATFN
. EXECUTE SUBPROCEDURE ESCAPE_SLASHES
. write( f_zsqlfn ) "LOAD DATA LOCAL "
. write( f_zsqlfn ) ["INFILE '" + MYSQL_FILENAME + "'"] /
                    " INTO TABLE " THIS_REC_NAME /
                    " COLUMNS TERMINATED BY '<SQL_DELIMINATOR>'" /
                    " OPTIONALLY ENCLOSED BY '""'"/
                    " ESCAPED BY '""'"/
                    " LINES TERMINATED BY '<LINE_TERMINATOR>'"  /
                    " IGNORE 1 LINES;"/


. write( f_data ) 'compute DELIM = <PQL_DELIMINATOR>'
. write( f_data ) ['open f_datafile / dsn = "' + Z_DATFN + '"/write/lrecl = 4000']

c include column headers
. write( f_data/noeol) 'write( f_datafile) '
. THIS_LINE = '"'
. for EACH_VAR = 1, nvarsc( EACH_REC )
.   compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.   THIS_LINE = THIS_LINE + THIS_VAR_NAME
.   if ( EACH_VAR lt nvarsc( EACH_REC ) ) THIS_LINE = THIS_LINE + '<DELIMINATOR>'
.   ifthen ( amod( EACH_VAR, 10 ) GE 0 ) | keep it to 10 variables on a line
.     THIS_LINE = THIS_LINE + '"'
.     write( f_data) 5T THIS_LINE
.     THIS_LINE = '     "'  | add indented space to make the new line readable
.   endif
. end for

. write( f_data ) 'process cases <CASE_RESTRICTION> '
. write( f_data ) 'process rec ' THIS_REC_NAME
. write( f_data ) 'get vars all'
. write( f_data ) 'DATA_LINE = ""'

. for EACH_VAR = 1, nvarsc( EACH_REC )
.   ifthen(  EACH_VAR LT nvarsc( EACH_REC ) )
.     compute Z_VTERM = 'DELIM'
.   else
.     compute Z_VTERM = ""
.   endif
.   compute THIS_VAR_NAME = lower( trim( varnamec( EACH_REC, EACH_VAR ) ) )
.   compute THIS_VTYPE    = vtype( EACH_REC, THIS_VAR_NAME )
.   compute THIS_VARLENG  = varleng( EACH_REC, THIS_VAR_NAME )

.   recode THIS_VAR_SQL_TYPE = THIS_VTYPE( 1 = 'VARCHAR' )( 2 = 'VARCHAR' )( 3 = 'DATE' )( 4 = 'TIME' )( 5 = 'INTEGER' )
    ( 6 = 'FLOAT' )( 7 = 'DOUBLE PRECISION' )( 8 = 'BIGINT' )
.   CHECK_WORD = THIS_VAR_NAME
.   EXECUTE SUBPROCEDURE CHECK_RESERVED_WORDS
.   write( f_datafile/noeol ) CLEAN_WORD

.   THIS_LINE = ''
.   ifthen( THIS_VAR_SQL_TYPE  = 'VARCHAR' )
.     THIS_LINE = 'DATA_VALUE = fst( ' + THIS_VAR_NAME + ', missing( ' + THIS_VAR_NAME + ' ) )'
.     write( f_data ) THIS_LINE
.     THIS_LINE = 'DATA_VALUE = ''"'' + DATA_VALUE + ''"'''
.   elseif( THIS_VAR_SQL_TYPE = 'INTEGER' or 'FLOAT' or 'DOUBLE PRECISION' or 'BIGINT' )
.     THIS_LINE = 'DATA_VALUE = format( fst( ' + THIS_VAR_NAME + ', missing( ' + THIS_VAR_NAME + ' ) ) )'
.   else
.     ifthen( THIS_VTYPE = 3 )
.       THIS_LINE = 'DATA_VALUE = datec( ' + THIS_VAR_NAME + ', "<date_format>" )'
.     else
.       THIS_LINE = 'DATA_VALUE = timec( ' + THIS_VAR_NAME + ', "<time_format>" )'
.     endif
.   endif
.   write( f_data ) THIS_LINE
.   write( f_data ) 'EXECUTE SUBPROCEDURE ADD_VALUE_TO_LINE' /

|   close the create table sql statement
.   ifthen(  EACH_VAR lt nvarsc( EACH_REC ) )
.     | DO NOTHING
.   else
.     write( f_data ) 'write( f_datafile ) DATA_LINE'
.     write( f_data ) 'end process rec'
.     write( f_data ) 'end process cases'
.     write( f_data ) 'close( f_datafile )'

.     write( f_data ) 'SUBPROCEDURE ADD_VALUE_TO_LINE'
.     write( f_data ) '. IFTHEN ( ( DATA_VALUE NE "" ) OR ( EXISTS( DATA_VALUE ) EQ 1 ) )'
.     write( f_data ) '.   DATA_LINE = DATA_LINE + DATA_VALUE'
.     write( f_data ) '. ELSE'
.     write( f_data ) '.   DATA_LINE = DATA_LINE + "<NULL_VALUE>"'
.     write( f_data ) '. ENDIF'
.     write( f_data ) '. DATA_LINE = DATA_LINE + DELIM'
.     write( f_data ) 'end subprocedure'

.     write( f_data ) 'end retrieval'
.     close( f_zsqlfn )
.   end if
. end for
end for

close ( f_data )
close ( loadit )

SUBPROCEDURE CHECK_RESERVED_WORDS
C CHECK TO SEE IF A VARIABLE IS A RESERVED WORD IN MYSQL
. MYSQL_RESERVED = 0
. CHECK_WORD = trim( upper( CHECK_WORD ) )
. CLEAN_WORD = CHECK_WORD
. DO REPEAT RESERVED_WORD =
    ACCESSIBLE ADD ALL ALTER ANALYZE AND AS ASC ASENSITIVE
    BEFORE BETWEEN BIGINT BINARY BLOB BOTH BY
    CALL CASCADE CASE CHANGE CHAR CHARACTER CHECK COLLATE COLUMN CONDITION CONSTRAINT CONTINUE CONVERT CREATE
    CROSS CURRENT_DATE CURRENT_TIME CURRENT_TIMESTAMP CURRENT_USER CURSOR
    DATABASE DATABASES DAY_HOUR DAY_MICROSECOND DAY_MINUTE DAY_SECOND DEC DECIMAL DECLARE DEFAULT DELAYED DELETE
    DESC DESCRIBE DETERMINISTIC DISTINCT DISTINCTROW DIV DOUBLE DROP DUAL
    EACH ELSE ELSEIF ENCLOSED ESCAPED EXISTS EXIT EXPLAIN
    FALSE FETCH FLOAT FLOAT4 FLOAT8 FOR FORCE FOREIGN FROM FULLTEXT
    GRANT GROUP HAVING HIGH_PRIORITY HOUR_MICROSECOND HOUR_MINUTE HOUR_SECOND
    IF IGNORE IN INDEX INFILE INNER INOUT INSENSITIVE INSERT INT INT1 INT2 INT3 INT4 INT8 INTEGER INTERVAL INTO IS ITERATE
    JOIN KEY KEYS KILL LEADING LEAVE LEFT LIKE LIMIT LINEAR LINES LOAD LOCALTIME
    LOCALTIMESTAMP LOCK LONG LONGBLOB LONGTEXT LOOP LOW_PRIORITY
    MASTER_SSL_VERIFY_SERVER_CERT MATCH MAXVALUE MEDIUMBLOB MEDIUMINT MEDIUMTEXT MIDDLEINT
    MINUTE_MICROSECOND MINUTE_SECOND MOD MODIFIES
    NATURAL NOT NO_WRITE_TO_BINLOG NULL NUMERIC ON OPTIMIZE OPTION OPTIONALLY OR ORDER OUT OUTER OUTFILE
    PRECISION PRIMARY PROCEDURE PURGE
    RANGE READ READS READ_WRITE REAL REFERENCES REGEXP RELEASE RENAME REPEAT
    REPLACE REQUIRE RESIGNAL RESTRICT RETURN REVOKE RIGHT RLIKE
    SCHEMA SCHEMAS SECOND_MICROSECOND SELECT SENSITIVE SEPARATOR SET SHOW
    SIGNAL SMALLINT SPATIAL SPECIFIC SQL SQLEXCEPTION SQLSTATE SQLWARNING
    SQL_BIG_RESULT SQL_CALC_FOUND_ROWS SQL_SMALL_RESULT SSL STARTING STRAIGHT_JOIN
    TABLE TERMINATED THEN TINYBLOB TINYINT TINYTEXT $TO$ TRAILING TRIGGER TRUE
    UNDO UNION UNIQUE UNLOCK UNSIGNED UPDATE USAGE USE USING UTC_DATE UTC_TIME UTC_TIMESTAMP
    VALUES VARBINARY VARCHAR VARCHARACTER VARYING WHEN
    WHERE WHILE WITH WRITE XOR YEAR_MONTH ZEROFILL
.   IFTHEN ( CHECK_WORD EQ 'RESERVED_WORD' )
.     CLEAN_WORD = "`" + CLEAN_WORD + "`"
.     MYSQL_RESERVED = 1; write // 'WARNING!!! mysql reserved word in schema: RESERVED_WORD' //; EXIT SUBPROCEDURE
.   ENDIF
. END REPEAT
END SUBPROCEDURE

SUBPROCEDURE CHECK_IO
. IFNOTTHEN ( IO_FEEDBACK EQ 0 )
.   WRITE 'ERRORS WITH NECESSARY FILE: ' CHECK_FILE ' ERROR: ' IO_FEEDBACK
.   Z_DUMMY = globals( "G_CONTINUE",  '0')
. ENDIF
END SUBPROCEDURE

subprocedure MAKE_FILE_LINE
C CREATE A LINE THAT CAN BE READ IN BY MYSQL
. IF ( EXISTS( CSV_LINE ) EQ 0 ) CSV_LINE = ""
. CSV_VALUE =  replace( CSV_VALUE, '"', '""', 99, 2, 0 ) | 2 double qoutes when imported turn into 1 double qoute
. CSV_VALUE =  replace( CSV_VALUE, "’", "'", 99, 2, 0 )  | There is an issue with the back qoutes and importing into MySQL`

. IFTHEN ( EXISTS( CSV_VALUE ) EQ 0)
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( pack( trimlr( CSV_VALUE ) ) EQ '' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSEIF ( CSV_VALUE EQ 'NULL' )
.   CSV_VALUE = '<NULL_VALUE>'
. ELSE
.   CSV_VALUE =  '"' + TRIMR( CSV_VALUE) + '"'       | ADD QOUTES AND GET RID OF TRAILING SPACES
. ENDIF

. CSV_LINE = CSV_LINE + CSV_VALUE + '<DELIMINATOR>'
end subprocedure

SUBPROCEDURE TRIM_LAST_COMMA
. CSV_LINE = TRIMR( CSV_LINE )
C . IF ( SUBSTR( CSV_LINE, LEN( CSV_LINE ), 1 ) EQ ',' ) CSV_LINE = SUBSTR( CSV_LINE, 1, LEN( CSV_LINE )  -1)
END SUBPROCEDURE

SUBPROCEDURE ESCAPE_SLASHES
c for windows the "\" in the file path must be escaped as it is a SQL reserved keyword
. IFNOT ( 0<WINDOWS_MACHINE> EQ 1 ) EXIT SUBPROCEDURE
. MYSQL_FILENAME = replace( MYSQL_FILENAME , '\', '\\', 99, 2, 0 )
END SUBPROCEDURE

end program

REMARK 'INCLUDING <DATAPROG>'

include file "<DATAPROG>"

REMARK 'CONTINUING TO CREATE DATABASE AND LOAD DATA: <LOADIT>'

cif eq '<G_CONTINUE>', '1'
program
pql escape "chmod 755 <LOADIT>"
pql escape "<LOADIT>"
end program
CIF END
END PROCEDURE
